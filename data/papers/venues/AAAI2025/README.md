# AAAI2025

Number of papers: 3

## [Counterexample Guided Program Repair Using Zero-Shot Learning and MaxSAT-based Fault Localization](paper_3.md)
- **Authors**: Orvalho, Pedro and Janota, Mikolas and Manquinho, Vasco M
- **Abstract**: Automated Program Repair (APR) for introductory programming assignments (IPAS) is motivated by the large number of student enrollments in programming courses each year. Since providing feedback on programming assignments requires substantial time and effort from faculty, personalized automated feedback often involves suggesting repairs to students' programs. Symbolic semantic repair approaches, which rely on Formal Methods (FM), check a program's execution against a test suite or reference solut...
- **Link**: [Read Paper](https://doi.org/10.1609/aaai.v39i1.32046)
- **Labels**: [program repair](../../labels/program_repair.md)


## [Less is more: adaptive program repair with bug localization and preference learning](paper_1.md)
- **Authors**: Dai, Zhenlong and Chen, Bingrui and Zhao, Zhuoluo and Tang, Xiu and Wu, Sai and Yao, Chang and Gao, Zhipeng and Chen, Jingyuan
- **Abstract**: Automated Program Repair (APR) is a task to automatically generate patches for the buggy code. However, most research focuses on generating correct patches while ignoring the consistency between the fixed code and the original buggy code. How to conduct adaptive bug fixing and generate patches with minimal modifications have seldom been investigated. To bridge this gap, we first introduce a novel task, namely AdaPR (Adaptive Program Repair). We then propose a two-stage approach AdaPatcher (Adapt...
- **Link**: [Read Paper](https://doi.org/10.1609/aaai.v39i1.31988)
- **Labels**: [program repair](../../labels/program_repair.md)


## [Online Prompt Selection for Program Synthesis](paper_2.md)
- **Authors**: Li, Yixuan and Frampton, Lewis and Mora, Federico and Polgreen, Elizabeth
- **Abstract**: Large Language Models (LLMs) demonstrate impressive capabilities in the domain of program synthesis. This level of performance is not, however, universal across all tasks, all LLMs and all prompting styles. There are many areas where one LLM dominates, one prompting style dominates, or where calling a symbolic solver is a better choice than an LLM. A key challenge for the user then, is to identify not only when an LLM is the right choice of solver, and the appropriate LLM to call for a given syn...
- **Link**: [Read Paper](https://doi.org/10.1609/aaai.v39i11.33227)
- **Labels**: [program synthesis](../../labels/program_synthesis.md)
