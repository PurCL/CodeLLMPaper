{
    "Rewriting the Code: A Simple Method for Large Language Model Augmented Code Search": {
        "type": "INPROCEEDINGS",
        "key": "li-etal-2024-rewriting",
        "author": "Li, Haochen and Zhou, Xin and Shen, Zhiqi",
        "booktitle": "ACL2024",
        "title": "Rewriting the Code: A Simple Method for Large Language Model Augmented Code Search",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "In code search, the Generation-Augmented Retrieval (GAR) framework, which generates exemplar code snippets to augment queries, has emerged as a promising strategy to address the principal challenge of modality misalignment between code snippets and natural language queries, particularly with the demonstrated code generation capabilities of Large Language Models (LLMs). Nevertheless, our preliminary investigations indicate that the improvements conferred by such an LLM-augmented framework are somewhat constrained. This limitation could potentially be ascribed to the fact that the generated codes, albeit functionally accurate, frequently display a pronounced stylistic deviation from the ground truth code in the codebase. In this paper, we extend the foundational GAR framework and propose a simple yet effective method that additionally Rewrites the Code (ReCo) within the codebase for style normalization. Experimental results demonstrate that ReCo significantly boosts retrieval accuracy across sparse (up to 35.7%), zero-shot dense (up to 27.6%), and fine-tuned dense (up to 23.6%) retrieval settings in diverse search scenarios. To further elucidate the advantages of ReCo and stimulate research in code style normalization, we introduce Code Style Similarity, the first metric tailored to quantify stylistic similarities in code. Notably, our empirical findings reveal the inadequacy of existing metrics in capturing stylistic nuances. The source code and data are available at https://github.com/Alex-HaochenLi/ReCo.",
        "keywords": [
            "code generation",
            "code completion",
            "empirical study"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.75",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Enhancing Large Language Models in Coding Through Multi-Perspective Self-Consistency": {
        "type": "INPROCEEDINGS",
        "key": "huang-etal-2024-enhancing",
        "author": "Huang, Baizhou and Lu, Shuai and Wan, Xiaojun and Duan, Nan",
        "booktitle": "ACL2024",
        "title": "Enhancing Large Language Models in Coding Through Multi-Perspective Self-Consistency",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large language models (LLMs) have exhibited remarkable ability in code generation. However, generating the correct solution in a single attempt still remains a challenge. Prior works utilize verification properties in software engineering to verify and re-rank solutions in a majority voting manner. But the assumption behind them that generated verification properties have better qualities than solutions may not always hold. In this paper, we treat them equally as different perspectives of LLMs\u2019 reasoning processes. We propose the Multi-Perspective Self-Consistency (MPSC) framework incorporating both inter- and intra-consistency across outputs from multiple perspectives. Specifically, we prompt LLMs to generate diverse outputs from three perspectives, Solution, Specification and Test case, constructing a 3-partite graph. With two measure functions of consistency, we embed both inter- and intra-consistency information into the graph. The optimal choice of solutions is then determined based on analysis in the graph.MPSC significantly boosts performance of foundation models (ChatGPT in this paper) on various benchmarks, including HumanEval (+15.91%), MBPP (+6.43%) and CodeContests (+9.37%), even surpassing GPT-4.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.78",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "UniCoder: Scaling Code Large Language Model via Universal Code": {
        "type": "INPROCEEDINGS",
        "key": "sun-etal-2024-unicoder",
        "author": "Sun, Tao and Chai, Linzheng and Yang, Jian and Yin, Yuwei and Guo, Hongcheng and Liu, Jiaheng and Wang, Bing and Yang, Liqun and Li, Zhoujun",
        "booktitle": "ACL2024",
        "title": "UniCoder: Scaling Code Large Language Model via Universal Code",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Intermediate reasoning or acting steps have successfully improved large language models (LLMs) for handling various downstream natural language processing (NLP) tasks.When applying LLMs for code generation, recent works mainly focus on directing the models to articulate intermediate natural-language reasoning steps, as in chain-of-thought (CoT) prompting, and then output code with the natural language or other structured intermediate steps. However, such output is not suitable for code translation or generation tasks since the standard CoT has different logical structures and forms of expression with the code. In this work, we introduce the universal code (UniCode) as the intermediate representation. It is a description of algorithm steps using a mix of conventions of programming languages, such as assignment operator, conditional operator, and loop. Hence, we collect an instruction dataset UniCoder-Instruct to train our model UniCoder on multi-task learning objectives. UniCoder-Instruct comprises natural-language questions, code solutions, and the corresponding universal code. The alignment between the intermediate universal code representation and the final code solution significantly improves the quality of the generated code. The experimental results demonstrate that UniCoder with the universal code significantly outperforms the previous prompting methods by a large margin, showcasing the effectiveness of the structural clues in pseudo-code.",
        "keywords": [
            "code generation",
            "program synthesis",
            "code model training",
            "IR model"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.100",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Virtual Compiler Is All You Need For Assembly Code Search": {
        "type": "INPROCEEDINGS",
        "key": "gao-etal-2024-virtual",
        "author": "Gao, Zeyu and Wang, Hao and Wang, Yuanda and Zhang, Chao",
        "booktitle": "ACL2024",
        "title": "Virtual Compiler Is All You Need For Assembly Code Search",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Assembly code search is vital for reducing the burden on reverse engineers, allowing them to quickly identify specific functions using natural language within vast binary programs.Despite its significance, this critical task is impeded by the complexities involved in building high-quality datasets. This paper explores training a Large Language Model (LLM) to emulate a general compiler. By leveraging Ubuntu packages to compile a dataset of 20 billion tokens, we further continue pre-train CodeLlama as a Virtual Compiler (ViC), capable of compiling any source code to assembly code. This approach allows for \u201cvirtual\u201d compilation across a wide range of programming languages without the need for a real compiler, preserving semantic equivalency and expanding the possibilities for assembly code dataset construction. Furthermore, we use ViC to construct a sufficiently large dataset for assembly code search. Employing this extensive dataset, we achieve a substantial improvement in assembly code search performance, with our model surpassing the leading baseline by 26%.",
        "keywords": [
            "code generation",
            "program translation",
            "code model training",
            "source code model"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.167",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "MPCoder: Multi-user Personalized Code Generator with Explicit and Implicit Style Representation Learning": {
        "type": "INPROCEEDINGS",
        "key": "dai-etal-2024-mpcoder",
        "author": "Dai, Zhenlong and Yao, Chang and Han, WenKang and Yuanying, Yuanying and Gao, Zhipeng and Chen, Jingyuan",
        "booktitle": "ACL2024",
        "title": "MPCoder: Multi-user Personalized Code Generator with Explicit and Implicit Style Representation Learning",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models (LLMs) have demonstrated great potential for assisting developers in their daily development. However, most research focuses on generating correct code, how to use LLMs to generate personalized code has seldom been investigated. To bridge this gap, we proposed MPCoder (Multi-user Personalized Code Generator) to generate personalized code for multiple users. To better learn coding style features, we utilize explicit coding style residual learning to capture the syntax code style standards and implicit style learning to capture the semantic code style conventions. We train a multi-user style adapter to better differentiate the implicit feature representations of different users through contrastive learning, ultimately enabling personalized code generation for multiple users. We further propose a novel evaluation metric for estimating similarities between codes of different coding styles. The experimental results show the effectiveness of our approach for this novel task.",
        "keywords": [
            "code generation",
            "program synthesis",
            "code model training",
            "source code model"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.207",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "StepCoder: Improving Code Generation with Reinforcement Learning from Compiler Feedback": {
        "type": "INPROCEEDINGS",
        "key": "dou-etal-2024-stepcoder",
        "author": "Dou, Shihan and Liu, Yan and Jia, Haoxiang and Zhou, Enyu and Xiong, Limao and Shan, Junjie and Huang, Caishuang and Wang, Xiao and Fan, Xiaoran and Xi, Zhiheng and Zhou, Yuhao and Ji, Tao and Zheng, Rui and Zhang, Qi and Gui, Tao and Huang, Xuanjing",
        "booktitle": "ACL2024",
        "title": "StepCoder: Improving Code Generation with Reinforcement Learning from Compiler Feedback",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "The advancement of large language models (LLMs) has significantly propelled the field of code generation. Previous work integrated reinforcement learning (RL) with compiler feedback for exploring the output space of LLMs to enhance code generation quality. However, the lengthy code generated by LLMs in response to complex human requirements makes RL exploration a challenge. Also, since the unit tests may not cover the complicated code, optimizing LLMs by using these unexecuted code snippets is ineffective. To tackle these challenges, we introduce StepCoder, a novel RL framework for code generation, consisting of two main components: CCCS addresses the exploration challenge by breaking the long sequences code generation task into a Curriculum of Code Completion Subtasks, while FGO only optimizes the model by masking the unexecuted code segments to provide Fine-Grained Optimization. In addition, we furthermore construct the APPS+ dataset for RL training, which is manually verified to ensure the correctness of unit tests. Experimental results show that our method improves the ability to explore the output space and outperforms state-of-the-art approaches in corresponding benchmarks. The code and dataset will be made available upon publication.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.251",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "DolphCoder: Echo-Locating Code Large Language Models with Diverse and Multi-Objective Instruction Tuning": {
        "type": "INPROCEEDINGS",
        "key": "wang-etal-2024-dolphcoder",
        "author": "Wang, Yejie and He, Keqing and Dong, Guanting and Wang, Pei and Zeng, Weihao and Diao, Muxi and Xu, Weiran and Wang, Jingang and Zhang, Mengdi and Cai, Xunliang",
        "booktitle": "ACL2024",
        "title": "DolphCoder: Echo-Locating Code Large Language Models with Diverse and Multi-Objective Instruction Tuning",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Code Large Language Models (Code LLMs) have demonstrated outstanding performance in code-related tasks. Various instruction finetuning approaches have been proposed to boost the code generation performance of pre-trained Code LLMs. In this paper, we introduce a diverse instruction model DolphCoder with self-evaluating for code generation. It learns diverse instruction targets and combines a code evaluation objective to enhance its code generation ability. Our model achieves superior performance on the HumanEval and MBPP benchmarks, demonstrating new insights for future code instruction tuning work. Our key findings are: (1) Augmenting more diverse responses with more distinct reasoning paths increases the code capability of LLMs. (2) Improving one\u2019s ability to evaluate the correctness of code also enhances their ability to create it.",
        "keywords": [
            "code generation",
            "program synthesis",
            "code model training",
            "source code model"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.259",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Who Wrote this Code? Watermarking for Code Generation": {
        "type": "INPROCEEDINGS",
        "key": "lee-etal-2024-wrote",
        "author": "Lee, Taehyun and Hong, Seokhee and Ahn, Jaewoo and Hong, Ilgee and Lee, Hwaran and Yun, Sangdoo and Shin, Jamin and Kim, Gunhee",
        "booktitle": "ACL2024",
        "title": "Who Wrote this Code? Watermarking for Code Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Since the remarkable generation performance of large language models raised ethical and legal concerns, approaches to detect machine-generated text by embedding watermarks are being developed.However, we discover that the existing works fail to function appropriately in code generation tasks due to the task\u2019s nature of having low entropy.Extending a logit-modifying watermark method, we propose Selective WatErmarking via Entropy Thresholding (SWEET), which enhances detection ability and mitigates code quality degeneration by removing low-entropy segments at generating and detecting watermarks.Our experiments show that SWEET significantly improves code quality preservation while outperforming all baselines, including post-hoc detection methods, in detecting machine-generated code text.Our code is available inhttps://github.com/hongcheki/sweet-watermark.",
        "keywords": [
            "code generation",
            "program synthesis",
            "code model security",
            "defense"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.268",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "MapCoder: Multi-Agent Code Generation for Competitive Problem Solving": {
        "type": "INPROCEEDINGS",
        "key": "islam-etal-2024-mapcoder",
        "author": "Islam, Md. Ashraful and Ali, Mohammed Eunus and Parvez, Md Rizwan",
        "booktitle": "ACL2024",
        "title": "MapCoder: Multi-Agent Code Generation for Competitive Problem Solving",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Code synthesis, which requires a deep understanding of complex natural language (NL) problem descriptions, generation of code instructions for complex algorithms and data structures, and the successful execution of comprehensive unit tests, presents a significant challenge. Thus, while large language models (LLMs) demonstrate impressive proficiency in natural language processing (NLP), their performance in code generation tasks remains limited. In this paper, we introduce a new approach to code generation tasks leveraging the multi-agent prompting that uniquely replicates the full cycle of program synthesis as observed in human developers. Our framework, MapCoder, consists of four LLM agents specifically designed to emulate the stages of this cycle: recalling relevant examples, planning, code generation, and debugging. After conducting thorough experiments, with multiple LLMs ablations and analyses across eight challenging competitive problem-solving and program synthesis benchmarks\u2014MapCoder showcases remarkable code generation capabilities, achieving their new state-of-the-art (pass@1) results\u2014(HumanEval 93.9%, MBPP 83.1%, APPS 22.0%, CodeContests 28.5%, and xCodeEval 45.3%). Moreover, our method consistently delivers superior performance across various programming languages and varying problem difficulties. We open-source our framework at https://github.com/Md-Ashraful-Pramanik/MapCoder.",
        "keywords": [
            "code generation",
            "program synthesis",
            "agent design"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.269",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "WaveCoder: Widespread And Versatile Enhancement For Code Large Language Models By Instruction Tuning": {
        "type": "INPROCEEDINGS",
        "key": "yu-etal-2024-wavecoder",
        "author": "Yu, Zhaojian and Zhang, Xin and Shang, Ning and Huang, Yangyu and Xu, Can and Zhao, Yishujie and Hu, Wenxiang and Yin, Qiufeng",
        "booktitle": "ACL2024",
        "title": "WaveCoder: Widespread And Versatile Enhancement For Code Large Language Models By Instruction Tuning",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recent work demonstrates that, after instruction tuning, Code Large Language Models (Code LLMs) can obtain impressive capabilities to address a wide range of code-related tasks. However, current instruction tuning methods for Code LLMs mainly focus on the traditional code generation task, resulting in poor performance in complex multi-task scenarios. In this paper, we concentrate on multiple code-related tasks and present WaveCoder, a series of Code LLMs trained with Widespread And Versatile Enhanced instruction data. To enable the models to tackle complex code-related tasks, we propose a method to stably generate diverse, high-quality instruction data from open source code dataset in multi-task scenarios and obtain CodeOcean, a dataset comprising 19,915 instruction instances across 4 code-related tasks, which is aimed at improving the generalization ability of Code LLM. Our experiments demonstrate that WaveCoder models significantly outperform other open-source models in terms of the generalization ability across different code-related tasks. Moreover, WaveCoder-Ultra-6.7B presents the state-of-the-art generalization abilities on a wide range of code-related tasks.",
        "keywords": [
            "code model training",
            "source code model"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.280",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "CodeScope: An Execution-based Multilingual Multitask Multidimensional Benchmark for Evaluating LLMs on Code Understanding and Generation": {
        "type": "INPROCEEDINGS",
        "key": "yan-etal-2024-codescope",
        "author": "Yan, Weixiang and Liu, Haitian and Wang, Yunkun and Li, Yunzhe and Chen, Qian and Wang, Wen and Lin, Tingyu and Zhao, Weishan and Zhu, Li and Sundaram, Hari and Deng, Shuiguang",
        "booktitle": "ACL2024",
        "title": "CodeScope: An Execution-based Multilingual Multitask Multidimensional Benchmark for Evaluating LLMs on Code Understanding and Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models (LLMs) have demonstrated remarkable performance on assisting humans in programming and facilitating programming automation. However, existing benchmarks for evaluating the code understanding and generation capacities of LLMs suffer from severe limitations. First, most benchmarks are insufficient as they focus on a narrow range of popular programming languages and specific tasks, whereas real-world software development scenarios show a critical need to implement systems with multilingual and multitask programming environments to satisfy diverse requirements. Second, most benchmarks fail to consider the actual executability and the consistency of execution results of the generated code. To bridge these gaps between existing benchmarks and expectations from practical applications, we introduce **CodeScope**, an execution-based, multilingual, multitask, multidimensional evaluation benchmark for comprehensively measuring LLM capabilities on coding tasks. CodeScope covers **43 programming languages** and **eight coding tasks**. It evaluates the coding performance of LLMs from three dimensions (perspectives): **length**, **difficulty**, and **efficiency**. To facilitate execution-based evaluations of code generation, we develop **MultiCodeEngine**, an automated code execution engine that supports 14 programming languages. Finally, we systematically evaluate and analyze eight mainstream LLMs and demonstrate the superior breadth and challenges of CodeScope for evaluating LLMs on code understanding and generation tasks compared to other benchmarks. The CodeScope benchmark and code are publicly available at https://github.com/WeixiangYAN/CodeScope.",
        "keywords": [
            "general coding task",
            "benchmark"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.301",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Experiential Co-Learning of Software-Developing Agents": {
        "type": "INPROCEEDINGS",
        "key": "qian-etal-2024-experiential",
        "author": "Qian, Chen and Dang, Yufan and Li, Jiahao and Liu, Wei and Xie, Zihao and Wang, YiFei and Chen, Weize and Yang, Cheng and Cong, Xin and Che, Xiaoyin and Liu, Zhiyuan and Sun, Maosong",
        "booktitle": "ACL2024",
        "title": "Experiential Co-Learning of Software-Developing Agents",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recent advancements in large language models (LLMs) have brought significant changes to various domains, especially through LLM-driven autonomous agents. A representative scenario is in software development, where LLM agents demonstrate efficient collaboration, task division, and assurance of software quality, markedly reducing the need for manual involvement. However, these agents frequently perform a variety of tasks independently, without benefiting from past experiences, which leads to repeated mistakes and inefficient attempts in multi-step task execution. To this end, we introduce Experiential Co-Learning, a novel LLM-agent learning framework in which instructor and assistant agents gather shortcut-oriented experiences from their historical trajectories and use these past experiences for future task execution. The extensive experiments demonstrate that the framework enables agents to tackle unseen software-developing tasks more effectively. We anticipate that our insights will guide LLM agents towards enhanced autonomy and contribute to their evolutionary growth in cooperative learning. The code and data are available at https://github.com/OpenBMB/ChatDev.",
        "keywords": [
            "general coding task",
            "agent design",
            "planning"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.305",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "XCodeEval: An Execution-based Large Scale Multilingual Multitask Benchmark for Code Understanding, Generation, Translation and Retrieval": {
        "type": "INPROCEEDINGS",
        "key": "khan-etal-2024-xcodeeval",
        "author": "Khan, Mohammad Abdullah Matin and Bari, M. Saiful and Long, Do and Wang, Weishi and Parvez, Md Rizwan and Joty, Shafiq",
        "booktitle": "ACL2024",
        "title": "XCodeEval: An Execution-based Large Scale Multilingual Multitask Benchmark for Code Understanding, Generation, Translation and Retrieval",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recently, pre-trained large language models (LLMs) have shown impressive abilities in generating codes from natural language descriptions, repairing buggy codes, translating codes between languages, and retrieving relevant code segments. However, the evaluation of these models has often been performed in a scattered way on only one or two specific tasks, in a few languages, at a partial granularity (e.g., function) level, and in many cases without proper training data. Even more concerning is that in most cases the evaluation of generated codes has been done in terms of mere lexical overlap with a reference code rather than actual execution. We introduce *xCodeEval*, the largest executable multilingual multitask benchmark to date consisting of 25 M document-level coding examples (16.5 B tokens) from about 7.5 K unique problems covering up to 11 programming languages with execution-level parallelism. It features a total of 7 tasks involving code understanding, generation, translation and retrieval. *xCodeEval* adopts an execution-based evaluation and offers a multilingual code execution engine, *ExecEval* that supports unit test based execution in all the 11 languages. To address the challenge of balancing the distributions of text-code samples over multiple attributes in validation/test sets, we propose a novel data splitting and a data selection schema based on the geometric mean and graph-theoretic principle. Our experiments with OpenAI\u2019s LLMs (zero-shot) and open-LLMs (zero-shot and fine-tuned) on the tasks and languages demonstrate to be quite challenging as per the current advancements in language models.",
        "keywords": [
            "general coding task",
            "benchmark"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.367",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Lightweight reranking for language model generations": {
        "type": "INPROCEEDINGS",
        "key": "jain-etal-2024-lightweight",
        "author": "Jain, Siddhartha and Ma, Xiaofei and Deoras, Anoop and Xiang, Bing",
        "booktitle": "ACL2024",
        "title": "Lightweight reranking for language model generations",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models (LLMs) can exhibit considerable variation in the quality of their sampled outputs. Reranking and selecting the best generation from the sampled set is a popular way of obtaining strong gains in generation quality. In this paper, we present a novel approach for reranking LLM generations. Unlike other techniques that might involve additional inferences or training a specialized reranker, our approach relies on easy to compute pairwise statistics between the generations that have minimal compute overhead. We show that our approach can be formalized as an extension of self-consistency and analyze its performance in that framework, theoretically as well as via simulations. We show strong improvements for selecting the best k generations for code generation tasks as well as robust improvements for the best generation for the tasks of autoformalization, summarization, and translation. While our approach only assumes black-box access to LLMs, we show that additional access to token probabilities can improve performance even further.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.376",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    },
    "Integrate the Essence and Eliminate the Dross: Fine-Grained Self-Consistency for Free-Form Language Generation": {
        "type": "INPROCEEDINGS",
        "key": "wang-etal-2024-integrate",
        "author": "Wang, Xinglin and Li, Yiwei and Feng, Shaoxiong and Yuan, Peiwen and Pan, Boyuan and Wang, Heda and Hu, Yao and Li, Kan",
        "booktitle": "ACL2024",
        "title": "Integrate the Essence and Eliminate the Dross: Fine-Grained Self-Consistency for Free-Form Language Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Self-consistency (SC), leveraging multiple samples from LLMs, shows significant gains on various reasoning tasks but struggles with free-form generation due to the difficulty of aggregating answers. Its variants, UCS and USC, rely on sample selection or voting mechanisms to improve output quality. These methods, however, face limitations due to their inability to fully utilize the nuanced consensus knowledge present within multiple candidate samples, often resulting in suboptimal outputs. We propose Fine-Grained Self-Consistency (FSC) to addresses these limitations by extracting and integrating segment-level commonalities from candidate samples, enhancing the performance of LLMs both in open-ended and reasoning tasks. Based on this, we present two additional strategies: candidate filtering, which enhances overall quality by identifying highly similar candidate sets, and merging, which reduces input token requirements by combining similar samples. The effectiveness of FSC is demonstrated through extensive experiments on various tasks, including summarization, code generation, and mathematical reasoning, using GPT-3.5-turbo and GPT-4. The results indicate significant improvements over baseline methods, showcasing the potential of FSC to optimize output quality by effectively synthesizing fine-grained consensus knowledge from multiple samples.",
        "keywords": [
            "general coding task",
            "empirical study"
        ],
        "url": "https://doi.org/10.18653/v1/2024.acl-long.634",
        "doi": "",
        "ISSN": "",
        "month": "August",
        "venue": "ACL2024"
    }
}