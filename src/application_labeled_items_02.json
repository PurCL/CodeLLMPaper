{
    "Socratic Human Feedback (SoHF): Expert Steering Strategies for LLM Code Generation": {
        "type": "INPROCEEDINGS",
        "key": "chidambaram-etal-2024-socratic",
        "author": "Chidambaram, Subramanian and Li, Li Erran and Bai, Min and Li, Xiaopeng and Lin, Kaixiang and Zhou, Xiong and Williams, Alex C.",
        "booktitle": "EMNLP-findings2024",
        "title": "Socratic Human Feedback (SoHF): Expert Steering Strategies for LLM Code Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models (LLMs) are increasingly used for generating code solutions, empowered by features like self-debugging and self-reflection. However, LLMs often struggle with complex programming problems without human guidance. This paper investigates the strategies employed by expert programmers to steer code-generating LLMs toward successful outcomes. Through a study involving experts using natural language to guide GPT-4, Gemini Ultra, and, Claude 3.5 Sonnet on highly difficult programming challenges, we frame our analysis using the \u201cSocratic Feedback\u201d paradigm for understanding effective steering strategies. By analyzing 30 conversational transcripts across all three models, we map observed feedback strategies to five stages of Socratic Questioning: Definition, Elenhus, Maieutic, Dialectic, and Counter-factual reasoning. We find evidence that by employing a combination of different Socratic feedback strategies across multiple turns, programmers successfully guided the models to solve 74% of the problems that the models initially failed to solve on their own.",
        "keywords": [
            "code generation",
            "program synthesis",
            "empirical study"
        ],
        "url": "https://aclanthology.org/2024.findings-emnlp.908",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-findings2024"
    },
    "PythonSaga: Redefining the Benchmark to Evaluate Code Generating LLMs": {
        "type": "INPROCEEDINGS",
        "key": "yadav-etal-2024-pythonsaga",
        "author": "Yadav, Ankit and Beniwal, Himanshu and Singh, Mayank",
        "booktitle": "EMNLP-findings2024",
        "title": "PythonSaga: Redefining the Benchmark to Evaluate Code Generating LLMs",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Driven by the surge in code generation using large language models (LLMs), numerous benchmarks have emerged to evaluate these LLMs capabilities. We conducted a large-scale human evaluation of *HumanEval* and *MBPP*, two popular benchmarks for Python code generation, analyzing their diversity and difficulty. Our findings unveil a critical bias towards a limited set of programming concepts, neglecting most of the other concepts entirely. Furthermore, we uncover a worrying prevalence of easy tasks that can inflate model performance estimations. To address these limitations, we propose a novel benchmark, *PythonSaga*, featuring 185 hand-crafted prompts in a balanced representation of 38 programming concepts across diverse difficulty levels. The robustness of our benchmark is demonstrated by the poor performance of existing Code-LLMs. The code and data set are openly available to the NLP community at this [URL](https://github.com/PythonSaga/PythonSaga).",
        "keywords": [
            "code generation",
            "program synthesis",
            "benchmark"
        ],
        "url": "https://aclanthology.org/2024.findings-emnlp.996",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-findings2024"
    },
    "Towards Efficient Fine-Tuning of Language Models With Organizational Data for Automated Software Review": {
        "type": "article",
        "key": "10.1109/TSE.2024.3428324",
        "author": "Nashaat, Mona and Miller, James",
        "title": "Towards Efficient Fine-Tuning of Language Models With Organizational Data for Automated Software Review",
        "year": "2024",
        "issue_date": "Sept. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "9",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3428324",
        "doi": "10.1109/TSE.2024.3428324",
        "abstract": "Large language models like BERT and GPT possess significant capabilities and potential impacts across various applications. Software engineers often use these models for code-related tasks, including generating, debugging, and summarizing code. Nevertheless, large language models still have several flaws, including model hallucination. (e.g., generating erroneous code and producing outdated and inaccurate programs) and the substantial computational resources and energy required for training and fine-tuning. To tackle these challenges, we propose CodeMentor, a framework for few-shot learning to train large language models with the data available within the organization. We employ the framework to train a language model for code review activities, such as code refinement and review generation. The framework utilizes heuristic rules and weak supervision techniques to leverage available data, such as previous review comments, issue reports, and related code updates. Then, the framework employs the constructed dataset to fine-tune LLMs for code review tasks. Additionally, the framework integrates domain expertise by employing reinforcement learning with human feedback. This allows domain experts to assess the generated code and enhance the model performance. Also, to assess the performance of the proposed model, we evaluate it with four state-of-the-art techniques in various code review tasks. The experimental results attest that CodeMentor enhances the performance in all tasks compared to the state-of-the-art approaches, with an improvement of up to 22.3%, 43.4%, and 24.3% in code quality estimation, review generation, and bug report summarization tasks, respectively.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "jul",
        "pages": "2240\u20132253",
        "numpages": "14",
        "venue": "TSE2024",
        "keywords": [
            "code generation",
            "program repair",
            "code model training",
            "source code model"
        ]
    },
    "LLM-Based Test-Driven Interactive Code Generation: User Study and Empirical Evaluation": {
        "type": "article",
        "key": "10.1109/TSE.2024.3428972",
        "author": "Fakhoury, Sarah and Naik, Aaditya and Sakkas, Georgios and Chakraborty, Saikat and Lahiri, Shuvendu K.",
        "title": "LLM-Based Test-Driven Interactive Code Generation: User Study and Empirical Evaluation",
        "year": "2024",
        "issue_date": "Sept. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "9",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3428972",
        "doi": "10.1109/TSE.2024.3428972",
        "abstract": "Large language models (LLMs) have shown great potential in automating significant aspects of coding by producing natural code from informal natural language (NL) intent. However, given NL is informal, it does not lend easily to checking that the generated code correctly satisfies the user intent. In this paper, we propose a novel interactive workflow &lt;sc&gt;TiCoder&lt;/sc&gt; for guided intent clarification (i.e., partial formalization) through tests to support the generation of more accurate code suggestions. Through a mixed methods user study with 15 programmers, we present an empirical evaluation of the effectiveness of the workflow to improve code generation accuracy. We find that participants using the proposed workflow are significantly more likely to correctly evaluate AI generated code, and report significantly less task-induced cognitive load. Furthermore, we test the potential of the workflow at scale with four different state-of-the-art LLMs on two python datasets, using an idealized proxy for a user feedback. We observe an average absolute improvement of 45.97\\% in the pass@1 code generation accuracy for both datasets and across all LLMs within 5 user interactions, in addition to the automatic generation of accompanying unit tests.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "jul",
        "pages": "2254\u20132268",
        "numpages": "15",
        "venue": "TSE2024",
        "keywords": [
            "code generation",
            "program synthesis",
            "empirical study"
        ]
    },
    "Chain-of-Thought in Neural Code Generation: From and for Lightweight Language Models": {
        "type": "article",
        "key": "10.1109/TSE.2024.3440503",
        "author": "Yang, Guang and Zhou, Yu and Chen, Xiang and Zhang, Xiangyu and Zhuo, Terry Yue and Chen, Taolue",
        "title": "Chain-of-Thought in Neural Code Generation: From and for Lightweight Language Models",
        "year": "2024",
        "issue_date": "Sept. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "9",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3440503",
        "doi": "10.1109/TSE.2024.3440503",
        "abstract": "Large Language Models (LLMs) have demonstrated remarkable potential in code generation. The integration of Chain of Thought (CoT) reasoning can further boost their performance. However, current CoT methods often require manual writing or LLMs with over 100 billion parameters to generate, impeding their applicability in resource-constrained scenarios. In this study, we investigate lightweight Language Models (&lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq1-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs), which are defined to have fewer than 10 billion parameters. Empirically, we find that most &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq2-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs cannot generate high-quality CoTs when prompted by the few-shot method, but can take advantage of high-quality CoTs generated elsewhere to improve their performance in code generation. Based on these findings, we design a novel approach &lt;monospace&gt;COTTON&lt;/monospace&gt; which can leverage &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq3-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs to automatically generate CoTs for code generation. We synthesize new datasets and conduct extensive experiments on various benchmarks. The results show that the CoTs generated by &lt;monospace&gt;COTTON&lt;/monospace&gt; outperform the baselines in terms of automated and human evaluation metrics. In particular, the CoTs generated by &lt;monospace&gt;COTTON&lt;/monospace&gt; boost various &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq4-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs to achieve higher performance gains than those generated by LLMs such as ChatGLM (130B), and are competitive with those generated by Gemini and gpt-3.5-turbo. The results also reveal that &lt;monospace&gt;COTTON&lt;/monospace&gt; not only improves the performance of &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq5-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs, but also enhances the performance of LLMs. Our study showcases the potential of &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$ell$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mi&gt;\u2113&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"zhou-ieq6-3440503.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;LMs in software engineering applications.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "aug",
        "pages": "2437\u20132457",
        "numpages": "21",
        "venue": "TSE2024",
        "keywords": [
            "code generation",
            "program synthesis",
            "empirical study"
        ]
    },
    "Isolating Compiler Bugs by Generating Effective Witness Programs With Large Language Models": {
        "type": "article",
        "key": "10.1109/TSE.2024.3397822",
        "author": "Tu, Haoxin and Zhou, Zhide and Jiang, He and Yusuf, Imam Nur Bani and Li, Yuxian and Jiang, Lingxiao",
        "title": "Isolating Compiler Bugs by Generating Effective Witness Programs With Large Language Models",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "7",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3397822",
        "doi": "10.1109/TSE.2024.3397822",
        "abstract": "Compiler bugs pose a significant threat to safety-critical applications, and promptly as well as effectively isolating these bugs is crucial for assuring the quality of compilers. However, the limited availability of debugging information on reported bugs complicates the compiler bug isolation task. Existing compiler bug isolation approaches convert the problem into a test program mutation problem, but they are still limited by ineffective mutation strategies or high human effort requirements. Drawing inspiration from the recent progress of pre-trained Large Language Models (LLMs), such as ChatGPT, in code generation, we propose a new approach named &lt;sc&gt;LLM4CBI&lt;/sc&gt; to utilize LLMs to generate effective test programs for compiler bug isolation. However, using LLMs directly for test program mutation may not yield the desired results due to the challenges associated with formulating precise prompts and selecting specialized prompts. To overcome the challenges, three new components are designed in &lt;sc&gt;LLM4CBI&lt;/sc&gt;. First, &lt;sc&gt;LLM4CBI&lt;/sc&gt; utilizes a program complexity-guided prompt production component, which leverages data and control flow analysis to identify the most valuable variables and locations in programs for mutation. Second, &lt;sc&gt;LLM4CBI&lt;/sc&gt; employs a memorized prompt selection component, which adopts reinforcement learning to select specialized prompts for mutating test programs continuously. Third, a test program validation component is proposed to select specialized feedback prompts to avoid repeating the same mistakes during the mutation process. Compared with the state-of-the-art approaches (DiWi and RecBi) over 120 real bugs from the two most popular compilers, namely GCC and LLVM, our evaluation demonstrates the advantages of &lt;sc&gt;LLM4CBI&lt;/sc&gt;: It can isolate 69.70\\%/21.74\\% and 24.44\\%/8.92\\% more bugs than DiWi and RecBi within Top-1/Top-5 ranked results. Additionally, we demonstrate that the LLMs component (i.e., GPT-3.5) used in &lt;sc&gt;LLM4CBI&lt;/sc&gt; can be easily replaced by other LLMs while still achieving reasonable results in comparison to related studies.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "may",
        "pages": "1768\u20131788",
        "numpages": "21",
        "venue": "TSE2024",
        "keywords": [
            "program testing",
            "debugging",
            "code model training",
            "source code model"
        ]
    },
    "ChatGPT vs SBST: A Comparative Assessment of Unit Test Suite Generation": {
        "type": "article",
        "key": "10.1109/TSE.2024.3382365",
        "author": "Tang, Yutian and Liu, Zhijie and Zhou, Zhichao and Luo, Xiapu",
        "title": "ChatGPT vs SBST: A Comparative Assessment of Unit Test Suite Generation",
        "year": "2024",
        "issue_date": "June 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "6",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3382365",
        "doi": "10.1109/TSE.2024.3382365",
        "abstract": "Recent advancements in large language models (LLMs) have demonstrated exceptional success in a wide range of general domain tasks, such as question answering and following instructions. Moreover, LLMs have shown potential in various software engineering applications. In this study, we present a systematic comparison of test suites generated by the ChatGPT LLM and the state-of-the-art SBST tool EvoSuite. Our comparison is based on several critical factors, including correctness, readability, code coverage, and bug detection capability. By highlighting the strengths and weaknesses of LLMs (specifically ChatGPT) in generating unit test cases compared to EvoSuite, this work provides valuable insights into the performance of LLMs in solving software engineering problems. Overall, our findings underscore the potential of LLMs in software engineering and pave the way for further research in this area.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "mar",
        "pages": "1340\u20131359",
        "numpages": "20",
        "venue": "TSE2024",
        "keywords": [
            "program testing",
            "unit testing",
            "empirical study"
        ]
    },
    "No Need to Lift a Finger Anymore? Assessing the Quality of Code Generation by ChatGPT": {
        "type": "article",
        "key": "10.1109/TSE.2024.3392499",
        "author": "Liu, Zhijie and Tang, Yutian and Luo, Xiapu and Zhou, Yuming and Zhang, Liang Feng",
        "title": "No Need to Lift a Finger Anymore? Assessing the Quality of Code Generation by ChatGPT",
        "year": "2024",
        "issue_date": "June 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "6",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3392499",
        "doi": "10.1109/TSE.2024.3392499",
        "abstract": "Large language models (LLMs) have demonstrated impressive capabilities across various natural language processing (NLP) tasks, such as machine translation, question answering, summarization, and so on. Additionally, LLMs are also highly valuable in supporting software engineering tasks, particularly in the field of code generation. Automatic code generation is a process of automatically generating source code or executable code based on given specifications or requirements, improving developer productivity. In this study, we perform a systematic empirical assessment to the quality of code generation using &lt;italic&gt;ChatGPT&lt;/italic&gt;, a recent state-of-the-art product LLM. We leverage 728 algorithm problems in five languages (i.e., C, C++, Java, Python, and JavaScript) and 18 CWEs with 54 code scenarios for the code generation task. Our evaluation encompasses a comprehensive analysis of code snippets generated by &lt;italic&gt;ChatGPT&lt;/italic&gt;, focusing on three critical aspects: correctness, complexity, and security. We also specifically investigate &lt;italic&gt;ChatGPT&lt;/italic&gt;'s ability to engage in multi-round fixing process (i.e., &lt;italic&gt;ChatGPT&lt;/italic&gt;'s dialog ability, chatting between users and &lt;italic&gt;ChatGPT&lt;/italic&gt; for fixing generated buggy code) of facilitating code generation. By delving into the generated code and examining the experimental results, this work provides valuable insights into the performance of &lt;italic&gt;ChatGPT&lt;/italic&gt; in tackling code generation tasks over the three critical aspects. The experimental results demonstrate that (1) &lt;italic&gt;ChatGPT&lt;/italic&gt; is better at generating functionally correct code for problems before 2021 in different languages than problems after 2021 with &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$48.14\\%$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mn&gt;48.14&lt;/mml:mn&gt;&lt;mml:mi mathvariant=\"normal\"&gt;\\%&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"tang-ieq1-3392499.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt; advantage in &lt;italic&gt;Accepted&lt;/italic&gt; rate on judgment platform, but &lt;italic&gt;ChatGPT&lt;/italic&gt;'s ability to directly fix erroneous code with multi-round fixing process to achieve correct functionality is relatively weak; (2) the distribution of cyclomatic and cognitive complexity levels for code snippets in different languages varies. Furthermore, the multi-round fixing process with &lt;italic&gt;ChatGPT &lt;/italic&gt; generally preserves or increases the complexity levels of code snippets; (3) in algorithm scenarios with languages of C, C++, and Java, and CWE scenarios with languages of C and Python3, the code generated by &lt;italic&gt;ChatGPT &lt;/italic&gt; has relevant vulnerabilities. However, the multi-round fixing process for vulnerable code snippets demonstrates promising results, with more than &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$89\\%$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mn&gt;89&lt;/mml:mn&gt;&lt;mml:mi mathvariant=\"normal\"&gt;\\%&lt;/mml:mi&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"tang-ieq2-3392499.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt; of vulnerabilities successfully addressed; and (4) code generation may be affected by &lt;italic&gt;ChatGPT&lt;/italic&gt;'s non-determinism factor, resulting in variations of code snippets in functional correctness, complexity, and security. Overall, our findings uncover potential issues and limitations that arise in the &lt;italic&gt;ChatGPT&lt;/italic&gt;-based code generation and lay the groundwork for improving AI and LLM-based code generation techniques.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "apr",
        "pages": "1548\u20131584",
        "numpages": "37",
        "venue": "TSE2024",
        "keywords": [
            "code generation",
            "program synthesis",
            "empirical study"
        ]
    },
    "Automatic Commit Message Generation: A Critical Review and Directions for Future Work": {
        "type": "article",
        "key": "10.1109/TSE.2024.3364675",
        "author": "Zhang, Yuxia and Qiu, Zhiqing and Stol, Klaas-Jan and Zhu, Wenhui and Zhu, Jiaxin and Tian, Yingchen and Liu, Hui",
        "title": "Automatic Commit Message Generation: A Critical Review and Directions for Future Work",
        "year": "2024",
        "issue_date": "April 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "4",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3364675",
        "doi": "10.1109/TSE.2024.3364675",
        "abstract": "Commit messages are critical for code comprehension and software maintenance. Writing a high-quality message requires skill and effort. To support developers and reduce their effort on this task, several approaches have been proposed to automatically generate commit messages. Despite the promising performance reported, we have identified three significant and prevalent threats in these automated approaches: 1) the datasets used to train and evaluate these approaches contain a considerable amount of \u2018noise\u2019; 2) current approaches only consider commits of a limited diff size; and 3) current approaches can only generate the subject of a commit message, not the message body. The first limitation may let the models \u2018learn\u2019 inappropriate messages in the training stage, and also lead to inflated performance results in their evaluation. The other two threats can considerably weaken the practical usability of these approaches. Further, with the rapid emergence of large language models (LLMs) that show superior performance in many software engineering tasks, it is worth asking: can LLMs address the challenge of long diffs and whole message generation? This article first reports the results of an empirical study to assess the impact of these three threats on the performance of the state-of-the-art auto generators of commit messages. We collected commit data of the Top 1,000 most-starred Java projects in GitHub and systematically removed noisy commits with bot-submitted and meaningless messages. We then compared the performance of four approaches representative of the state-of-the-art before and after the removal of noisy messages, or with different lengths of commit diffs. We also conducted a qualitative survey with developers to investigate their perspectives on simply generating message subjects. Finally, we evaluate the performance of two representative LLMs, namely UniXcoder and ChatGPT, in generating more practical commit messages. The results demonstrate that generating commit messages is of great practical value, considerable work is needed to mature the current state-of-the-art, and LLMs can be an avenue worth trying to address the current limitations. Our analyses provide insights for future work to achieve better performance in practice.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "feb",
        "pages": "816\u2013835",
        "numpages": "20",
        "venue": "TSE2024",
        "keywords": [
            "software maintenance and deployment",
            "commit message generation",
            "empirical study"
        ]
    },
    "Software Testing With Large Language Models: Survey, Landscape, and Vision": {
        "type": "article",
        "key": "10.1109/TSE.2024.3368208",
        "author": "Wang, Junjie and Huang, Yuchao and Chen, Chunyang and Liu, Zhe and Wang, Song and Wang, Qing",
        "title": "Software Testing With Large Language Models: Survey, Landscape, and Vision",
        "year": "2024",
        "issue_date": "April 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "4",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3368208",
        "doi": "10.1109/TSE.2024.3368208",
        "abstract": "Pre-trained large language models (LLMs) have recently emerged as a breakthrough technology in natural language processing and artificial intelligence, with the ability to handle large-scale datasets and exhibit remarkable performance across a wide range of tasks. Meanwhile, software testing is a crucial undertaking that serves as a cornerstone for ensuring the quality and reliability of software products. As the scope and complexity of software systems continue to grow, the need for more effective software testing techniques becomes increasingly urgent, making it an area ripe for innovative approaches such as the use of LLMs. This paper provides a comprehensive review of the utilization of LLMs in software testing. It analyzes 102 relevant studies that have used LLMs for software testing, from both the software testing and LLMs perspectives. The paper presents a detailed discussion of the software testing tasks for which LLMs are commonly used, among which test case preparation and program repair are the most representative. It also analyzes the commonly used LLMs, the types of prompt engineering that are employed, as well as the accompanied techniques with these LLMs. It also summarizes the key challenges and potential opportunities in this direction. This work can serve as a roadmap for future research in this area, highlighting potential avenues for exploration, and identifying gaps in our current understanding of the use of LLMs in software testing.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "feb",
        "pages": "911\u2013936",
        "numpages": "26",
        "venue": "TSE2024",
        "keywords": [
            "program testing",
            "survey"
        ]
    },
    "Code Review Automation: Strengths and Weaknesses of the State of the Art": {
        "type": "article",
        "key": "10.1109/TSE.2023.3348172",
        "author": "Tufano, Rosalia and Dabi\\'{c}, Ozren and Mastropaolo, Antonio and Ciniselli, Matteo and Bavota, Gabriele",
        "title": "Code Review Automation: Strengths and Weaknesses of the State of the Art",
        "year": "2024",
        "issue_date": "Feb. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "2",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2023.3348172",
        "doi": "10.1109/TSE.2023.3348172",
        "abstract": "The automation of code review has been tackled by several researchers with the goal of reducing its cost. The adoption of deep learning in software engineering pushed the automation to new boundaries, with techniques &lt;italic&gt;imitating&lt;/italic&gt; developers in generative tasks, such as commenting on a code change as a reviewer would do or addressing a reviewer's comment by modifying code. The performance of these techniques is usually assessed through quantitative metrics, &lt;italic&gt;e.g.,&lt;/italic&gt; the percentage of instances in the test set for which correct predictions are generated, leaving many open questions on the techniques\u2019 capabilities. For example, knowing that an approach is able to correctly address a reviewer's comment in 10\\% of cases is of little value without knowing what was asked by the reviewer: What if in all successful cases the code change required to address the comment was just the removal of an empty line? In this paper we aim at characterizing the cases in which three code review automation techniques tend to succeed or fail in the two above-described tasks. The study has a strong qualitative focus, with &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$sim$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math&gt;&lt;mml:mo&gt;\u223c&lt;/mml:mo&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"bavota-ieq1-3348172.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt;105 man-hours of manual inspection invested in manually analyzing correct and wrong predictions generated by the three techniques, for a total of 2,291 inspected predictions. The output of this analysis are two taxonomies reporting, for each of the two tasks, the types of code changes on which the experimented techniques tend to succeed or to fail, pointing to areas for future work. A result of our manual analysis was also the identification of several issues in the datasets used to train and test the experimented techniques. Finally, we assess the importance of researching in techniques specialized for code review automation by comparing their performance with ChatGPT, a general purpose large language model, finding that ChatGPT struggles in commenting code as a human reviewer would do.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "jan",
        "pages": "338\u2013353",
        "numpages": "16",
        "venue": "TSE2024",
        "keywords": [
            "code review",
            "empirical study"
        ]
    },
    "An Empirical Evaluation of Using Large Language Models for Automated Unit Test Generation": {
        "type": "article",
        "key": "10.1109/TSE.2023.3334955",
        "author": "Sch\\\"{a}fer, Max and Nadi, Sarah and Eghbali, Aryaz and Tip, Frank",
        "title": "An Empirical Evaluation of Using Large Language Models for Automated Unit Test Generation",
        "year": "2023",
        "issue_date": "Jan. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "1",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2023.3334955",
        "doi": "10.1109/TSE.2023.3334955",
        "abstract": "Unit tests play a key role in ensuring the correctness of software. However, manually creating unit tests is a laborious task, motivating the need for automation. Large Language Models (LLMs) have recently been applied to various aspects of software development, including their suggested use for automated generation of unit tests, but while requiring additional training or few-shot learning on examples of existing tests. This paper presents a large-scale empirical evaluation on the effectiveness of LLMs for automated unit test generation without requiring additional training or manual effort. Concretely, we consider an approach where the LLM is provided with prompts that include the signature and implementation of a function under test, along with usage examples extracted from documentation. Furthermore, if a generated test fails, our approach attempts to generate a new test that fixes the problem by re-prompting the model with the failing test and error message. We implement our approach in &lt;sc&gt;TestPilot&lt;/sc&gt;, an adaptive LLM-based test generation tool for JavaScript that automatically generates unit tests for the methods in a given project's API. We evaluate &lt;sc&gt;TestPilot&lt;/sc&gt; using OpenAI's &lt;italic&gt;gpt3.5-turbo&lt;/italic&gt; LLM on 25 npm packages with a total of 1,684 API functions. The generated tests achieve a median statement coverage of 70.2\\% and branch coverage of 52.8\\%. In contrast, the state-of-the feedback-directed JavaScript test generation technique, Nessie, achieves only 51.3\\% statement coverage and 25.6\\% branch coverage. Furthermore, experiments with excluding parts of the information included in the prompts show that all components contribute towards the generation of effective test suites. We also find that 92.8\\% of &lt;sc&gt;TestPilot&lt;/sc&gt;'s generated tests have &lt;inline-formula&gt;&lt;tex-math notation=\"LaTeX\"&gt;$leq$&lt;/tex-math&gt;&lt;alternatives&gt;&lt;mml:math display=\"inline\"&gt;&lt;mml:mo&gt;\u2264&lt;/mml:mo&gt;&lt;/mml:math&gt;&lt;inline-graphic xlink:href=\"schaefer-ieq1-3334955.gif\"/&gt;&lt;/alternatives&gt;&lt;/inline-formula&gt; 50\\% similarity with existing tests (as measured by normalized edit distance), with none of them being exact copies. Finally, we run &lt;sc&gt;TestPilot&lt;/sc&gt; with two additional LLMs, OpenAI's older &lt;italic&gt;code-cushman-002&lt;/italic&gt; LLM and &lt;italic&gt;StarCoder&lt;/italic&gt;, an LLM for which the training process is publicly documented. Overall, we observed similar results with the former (68.2\\% median statement coverage), and somewhat worse results with the latter (54.0\\% median statement coverage), suggesting that the effectiveness of the approach is influenced by the size and training set of the LLM, but does not fundamentally depend on the specific model.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "nov",
        "pages": "85\u2013105",
        "numpages": "21",
        "venue": "TSE2024",
        "keywords": [
            "program testing",
            "unit testing",
            "empirical study"
        ]
    },
    "Learning to Generate Structured Code Summaries From Hybrid Code Context": {
        "type": "article",
        "key": "10.1109/TSE.2024.3439562",
        "author": "Zhou, Ziyi and Li, Mingchen and Yu, Huiqun and Fan, Guisheng and Yang, Penghui and Huang, Zijie",
        "title": "Learning to Generate Structured Code Summaries From Hybrid Code Context",
        "year": "2024",
        "issue_date": "Oct. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "10",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3439562",
        "doi": "10.1109/TSE.2024.3439562",
        "abstract": "Code summarization aims to automatically generate natural language descriptions for code, and has become a rapidly expanding research area in the past decades. Unfortunately, existing approaches mainly focus on the \u201cone-to-one\u201d mapping from methods to short descriptions, which hinders them from becoming practical tools: 1) The program context is ignored, so they have difficulty in predicting keywords outside the target method; 2) They are typically trained to generate brief function descriptions with only one sentence in length, and therefore have difficulty in providing specific information. These drawbacks are partially due to the limitations of public code summarization datasets. In this paper, we first build a large code summarization dataset including different code contexts and summary content annotations, and then propose a deep learning framework that learns to generate structured code summaries from hybrid program context, named StructCodeSum. It provides both an LLM-based approach and a lightweight approach which are suitable for different scenarios. Given a target method, StructCodeSum predicts its function description, return description, parameter description, and usage description through hybrid code context, and ultimately builds a Javadoc-style code summary. The hybrid code context consists of path context, class context, documentation context and call context of the target method. Extensive experimental results demonstrate: 1) The hybrid context covers more than 70\\% of the summary tokens in average and significantly boosts the model performance; 2) When generating function descriptions, StructCodeSum outperforms the state-of-the-art approaches by a large margin; 3) According to human evaluation, the quality of the structured summaries generated by our approach is better than the documentation generated by Code Llama.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "aug",
        "pages": "2512\u20132528",
        "numpages": "17",
        "venue": "TSE2024",
        "keywords": [
            "static analysis",
            "code summarization",
            "benchmark"
        ]
    },
    "Follow-Up Attention: An Empirical Study of Developer and Neural Model Code Exploration": {
        "type": "article",
        "key": "10.1109/TSE.2024.3445338",
        "author": "Paltenghi, Matteo and Pandita, Rahul and Henley, Austin Z. and Ziegler, Albert",
        "title": "Follow-Up Attention: An Empirical Study of Developer and Neural Model Code Exploration",
        "year": "2024",
        "issue_date": "Oct. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "10",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3445338",
        "doi": "10.1109/TSE.2024.3445338",
        "abstract": "Recent neural models of code, such as OpenAI Codex and AlphaCode, have demonstrated remarkable proficiency at code generation due to the underlying attention mechanism. However, it often remains unclear how the models actually process code, and to what extent their reasoning and the way their attention mechanism scans the code matches the patterns of developers. A poor understanding of the model reasoning process limits the way in which current neural models are leveraged today, so far mostly for their raw prediction. To fill this gap, this work studies how the processed attention signal of three open large language models - CodeGen, InCoder and GPT-J - agrees with how developers look at and explore code when each answers the same sensemaking questions about code. Furthermore, we contribute an open-source eye-tracking dataset comprising 92 manually-labeled sessions from 25 developers engaged in sensemaking tasks. We empirically evaluate five heuristics that do not use the attention and ten attention-based post-processing approaches of the attention signal of CodeGen against our ground truth of developers exploring code, including the novel concept of &lt;italic&gt;follow-up attention&lt;/italic&gt; which exhibits the highest agreement between model and human attention. Our follow-up attention method can predict the next line a developer will look at with 47\\% accuracy. This outperforms the baseline prediction accuracy of 42.3\\%, which uses the session history of other developers to recommend the next line. These results demonstrate the potential of leveraging the attention signal of pre-trained models for effective code exploration.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "aug",
        "pages": "2568\u20132582",
        "numpages": "15",
        "venue": "TSE2024",
        "keywords": [
            "code generation",
            "code completion",
            "code model training",
            "source code model",
            "benchmark"
        ]
    },
    "Evaluating Diverse Large Language Models for Automatic and General Bug Reproduction": {
        "type": "article",
        "key": "10.1109/TSE.2024.3450837",
        "author": "Kang, Sungmin and Yoon, Juyeon and Askarbekkyzy, Nargiz and Yoo, Shin",
        "title": "Evaluating Diverse Large Language Models for Automatic and General Bug Reproduction",
        "year": "2024",
        "issue_date": "Oct. 2024",
        "publisher": "IEEE Press",
        "volume": "50",
        "number": "10",
        "issn": "0098-5589",
        "url": "https://doi.org/10.1109/TSE.2024.3450837",
        "doi": "10.1109/TSE.2024.3450837",
        "abstract": "Bug reproduction is a critical developer activity that is also challenging to automate, as bug reports are often in natural language and thus can be difficult to transform to test cases consistently. As a result, existing techniques mostly focused on crash bugs, which are easier to automatically detect and verify. In this work, we overcome this limitation by using large language models (LLMs), which have been demonstrated to be adept at natural language processing and code generation. By prompting LLMs to generate bug-reproducing tests, and via a post-processing pipeline to automatically identify promising generated tests, our proposed technique &lt;sc&gt;Libro&lt;/sc&gt; could successfully reproduce about one-third of all bugs in the widely used Defects4J benchmark. Furthermore, our extensive evaluation on 15 LLMs, including 11 open-source LLMs, suggests that open-source LLMs also demonstrate substantial potential, with the StarCoder LLM achieving 70\\% of the reproduction performance of the closed-source OpenAI LLM code-davinci-002 on the large Defects4J benchmark, and 90\\% of performance on a held-out bug dataset likely not part of any LLM's training data. In addition, our experiments on LLMs of different sizes show that bug reproduction using &lt;sc&gt;Libro&lt;/sc&gt; improves as LLM size increases, providing information as to which LLMs can be used with the &lt;sc&gt;Libro&lt;/sc&gt; pipeline.",
        "journal": "IEEE Trans. Softw. Eng.",
        "month": "sep",
        "pages": "2677\u20132694",
        "numpages": "18",
        "venue": "TSE2024",
        "keywords": [
            "program testing",
            "bug reproduction",
            "empirical study"
        ]
    },
    "DeGPT: Optimizing Decompiler Output with LLM": {
        "type": "INPROCEEDINGS",
        "key": "",
        "author": "Peiwei Hu and Chinese Academy of Sciences and Beijing and China) and Ruigang Liang and Chinese Academy of Sciences and Beijing and China) and Kai Chen and Chinese Academy of Sciences and China)",
        "booktitle": "NDSS2024",
        "title": "DeGPT: Optimizing Decompiler Output with LLM",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Reverse engineering is essential in malware analysis, vulnerability discovery, etc. Decompilers assist the reverse engineers by lifting the assembly to the high-level programming language, which highly boosts binary comprehension. However, decompilers suffer from problems such as meaningless variable names, redundant variables, and lacking comments describing the purpose of the code. Previous studies have shown promising performance in refining the decompiler output by training the models with huge datasets containing various decompiler outputs. However, even datasets that take much time to construct cover limited binaries in the real world. The performance degrades severely facing the binary migration.In this paper, we present DeGPT, an end-to-end framework aiming to optimize the decompiler output to improve its readability and simplicity and further assist the reverse engineers in understanding the binaries better. The Large Language Model (LLM) can mitigate performance degradation with its extraordinary ability endowed by large model size and training set containing rich multi-modal data. However, its potential is difficult to unlock through one-shot use. Thus, we propose the three-role mechanism, which includes referee (R_ref), advisor (R_adv), and operator (R_ope), to adapt the LLM to our optimization tasks. Specifically, R_ref provides the optimization scheme for the target decompiler output, while R_adv gives the rectification measures based on the scheme, and R_ope inspects whether the optimization changes the original function semantics and concludes the final verdict about whether to accept the optimizations. We evaluate DeGPT on the datasets containing decompiler outputs of various software, such as the practical command line tools, malware, a library for audio processing, and implementations of algorithms. The experimental results show that even on the output of the current top-level decompiler (Ghidra), DeGPT can achieve 24.4% reduction in the cognitive burden of understanding the decompiler outputs and provide comments of which 62.9% can provide practical semantics for the reverse engineers to help the understanding of binaries. Our user surveys also show that the optimizations can significantly simplify the code and add helpful semantic information (variable names and comments), facilitating a quick and accurate understanding of the binary.",
        "keywords": [
            "code generation",
            "program decompilation"
        ],
        "url": "https://www.ndss-symposium.org/ndss-paper/degpt-optimizing-decompiler-output-with-llm",
        "doi": "",
        "ISSN": "",
        "month": "",
        "venue": "NDSS2024"
    },
    "Large Language Model guided Protocol Fuzzing": {
        "type": "INPROCEEDINGS",
        "key": "",
        "author": "Ruijie Meng and Singapore) and Martin Mirchev and Marcel B\u00f6hme and Germany and Monash University and Australia) and Abhik Roychoudhury",
        "booktitle": "NDSS2024",
        "title": "Large Language Model guided Protocol Fuzzing",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "How to find security flaws in a protocol implementation without a machine-readable specification of the protocol? Facing the internet, protocol implementations are particularly security-critical software systems where inputs must adhere to a specific structure and order that is often informally specified in hundreds of pages in natural language (RFC). Without some machine-readable version of that protocol, it is difficult to automatically generate valid test inputs for its implementation that follow the required structure and order. It is possible to partially alleviate this challenge using mutational fuzzing on a set of recorded message sequences as seed inputs. However, the set of available seeds is often quite limited and will hardly cover the great diversity of protocol states and input structures.In this paper, we explore the opportunities of systematic interaction with a pre-trained large language models (LLM) which has ingested millions of pages of human-readable protocol specifications, to draw out machine-readable information about the protocol that can be used during protocol fuzzing.  We use the knowledge of the LLMs about protocol message types for well-known protocols. We also checked the LLM's capability in detecting ``states\" for stateful protocol implementations by generating sequences of messages and predicting response codes. Based on these observations, we have developed an LLM-guided protocol implementation fuzzing engine. Our protocol fuzzer ChatAFL constructs grammars for each message type in a protocol, and then mutates messages or predicts the next messages in a message sequence via interactions with LLMs. Experiments on a wide range of real-world protocols from ProFuzzbench show significant efficacy in state and code coverage. Our LLM-guided stateful fuzzer was compared with state-of-the-art fuzzers AFLNet and NSFuzz. ChatAFL covers 47.6% and 42.7% more state transitions, 29.6% and 25.8% more states, and 5.8% and 6.7% more code, respectively. Apart from enhanced coverage, ChatAFL discovered nine distinct and previously unknown vulnerabilities in widely-used and extensively-tested protocol implementations while AFLNet and NSFuzz only discover three and four of them, respectively.",
        "keywords": [
            "program testing",
            "fuzzing",
            "protocol fuzzing"
        ],
        "url": "https://www.ndss-symposium.org/ndss-paper/large-language-model-guided-protocol-fuzzing",
        "doi": "",
        "ISSN": "",
        "month": "",
        "venue": "NDSS2024"
    },
    "Face It Yourselves: An LLM-Based Two-Stage Strategy to Localize Configuration Errors via Logs": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652106",
        "author": "Shan, Shiwen and Huo, Yintong and Su, Yuxin and Li, Yichen and Li, Dan and Zheng, Zibin",
        "title": "Face It Yourselves: An LLM-Based Two-Stage Strategy to Localize Configuration Errors via Logs",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652106",
        "doi": "10.1145/3650212.3652106",
        "abstract": "Configurable software systems are prone to configuration errors, resulting in significant losses to companies. However, diagnosing these errors is challenging due to the vast and complex configuration space. These errors pose significant challenges for both experienced maintainers and new end-users, particularly those without access to the source code of the software systems. Given that logs are easily accessible to most end-users, we conduct a preliminary study to outline the challenges and opportunities of utilizing logs in localizing configuration errors. Based on the insights gained from the preliminary study, we propose an LLM-based two-stage strategy for end-users to localize the root-cause configuration properties based on logs. We further implement a tool, LogConfigLocalizer, aligned with the design of the aforementioned strategy, hoping to assist end-users in coping with configuration errors through log analysis. To the best of our knowledge, this is the first work to localize the root-cause configuration properties for end-users based on Large Language Models (LLMs) and logs. We evaluate the proposed strategy on Hadoop by LogConfigLocalizer and prove its efficiency with an average accuracy as high as 99.91\\%. Additionally, we also demonstrate the effectiveness and necessity of different phases of the methodology by comparing it with two other variants and a baseline tool. Moreover, we validate the proposed methodology through a practical case study to demonstrate its effectiveness and feasibility.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "13\u201325",
        "numpages": "13",
        "keywords": [
            "software maintenance and deployment",
            "software configuration"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "CoderUJB: An Executable and Unified Java Benchmark for Practical Programming Scenarios": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652115",
        "author": "Zeng, Zhengran and Wang, Yidong and Xie, Rui and Ye, Wei and Zhang, Shikun",
        "title": "CoderUJB: An Executable and Unified Java Benchmark for Practical Programming Scenarios",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652115",
        "doi": "10.1145/3650212.3652115",
        "abstract": "In the evolving landscape of large language models (LLMs) tailored for software engineering, the need for benchmarks that accurately reflect real-world development scenarios is paramount. Current benchmarks are either too simplistic or fail to capture the multi-tasking nature of software development. To address this, we introduce CoderUJB, a new benchmark designed to evaluate LLMs across diverse Java programming tasks that are executable and reflective of actual development scenarios, acknowledging Java's prevalence in real-world software production. CoderUJB comprises 2,239 programming questions derived from 17 real open-source Java projects and spans five practical programming tasks. Our empirical study on this benchmark investigates the coding abilities of various open-source and closed-source LLMs, examining the effects of continued pre-training in specific programming languages code and instruction fine-tuning on their performance. The findings indicate that while LLMs exhibit strong potential, challenges remain, particularly in non-functional code generation (e.g., test generation and defect detection). Importantly, our results advise caution in the specific programming languages continued pre-training and instruction fine-tuning, as these techniques could hinder model performance on certain tasks, suggesting the need for more nuanced strategies. CoderUJB thus marks a significant step towards more realistic evaluations of programming capabilities in LLMs, and our study provides valuable insights for the future development of these models in software engineering.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "124\u2013136",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program testing",
            "bug detection",
            "benchmark"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "SCALE: Constructing Structured Natural Language Comment Trees for Software Vulnerability Detection": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652124",
        "author": "Wen, Xin-Cheng and Gao, Cuiyun and Gao, Shuzheng and Xiao, Yang and Lyu, Michael R.",
        "title": "SCALE: Constructing Structured Natural Language Comment Trees for Software Vulnerability Detection",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652124",
        "doi": "10.1145/3650212.3652124",
        "abstract": "Recently, there has been a growing interest in automatic software vulnerability detection.     Pre-trained model-based approaches have demonstrated superior performance than other Deep Learning (DL)-based approaches in detecting vulnerabilities.     However, the existing pre-trained model-based approaches generally employ code sequences as input during prediction, and may ignore vulnerability-related structural information, as reflected in the following two aspects.     First, they tend to fail to infer the semantics of the code statements with complex logic such as those containing multiple operators and pointers.     Second, they are hard to comprehend various code execution sequences, which is essential for precise vulnerability detection.         To mitigate the challenges, we propose a Structured Natural Language Comment tree-based vulnerAbiLity dEtection framework based on the pre-trained models, named . The proposed Structured Natural Language Comment Tree (SCT) integrates the semantics of code statements with code execution sequences based on the Abstract Syntax Trees (ASTs).Specifically, comprises three main modules:     (1) Comment Tree Construction, which aims at enhancing the model\u2019s ability to infer the semantics of code statements by first incorporating Large Language Models (LLMs) for comment generation and then adding the comment node to ASTs.     (2) Structured Natural Language Comment Tree Construction, which aims at explicitly involving code execution sequence by combining the code syntax templates with the comment tree.     (3) SCT-Enhanced Representation, which finally incorporates the constructed SCTs for well capturing vulnerability patterns.     Experimental results demonstrate that outperforms the best-performing baseline, including the pre-trained model and LLMs, with improvements of 2.96\\%, 13.47\\%, and 3.75\\% in terms of F1 score on the FFMPeg+Qemu, Reveal, and SVulD datasets, respectively. Furthermore, can be applied to different pre-trained models, such as CodeBERT and UniXcoder, yielding the F1 score performance enhancements ranging from 1.37\\% to 10.87\\%.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "235\u2013247",
        "numpages": "13",
        "keywords": [
            "static analysis",
            "bug detection"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "LPR: Large Language Models-Aided Program Reduction": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652126",
        "author": "Zhang, Mengxiao and Tian, Yongqiang and Xu, Zhenyang and Dong, Yiwen and Tan, Shin Hwei and Sun, Chengnian",
        "title": "LPR: Large Language Models-Aided Program Reduction",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652126",
        "doi": "10.1145/3650212.3652126",
        "abstract": "Program reduction is a widely used technique to facilitate debugging                compilers by automatically minimizing programs that trigger                compiler bugs. Existing program reduction techniques are either                generic to a wide range of languages (such as Perses and Vulcan)                or specifically optimized for one certain language by exploiting                language-specific knowledge (e.g., C-Reduce). However, synergistically                combining both generality across languages and optimality                to a specific language in program reduction is yet to be explored.                This paper proposes LPR, the first LLMs-aided technique leveraging                LLMs to perform language-specific program reduction for                multiple languages. The key insight is to utilize both the language                generality of program reducers such as Perses and the languagespecific                semantics learned by LLMs. Concretely, language-generic                program reducers can efficiently reduce programs into a small size                that is suitable for LLMs to process; LLMs can effectively transform                programs via the learned semantics to create new reduction opportunities                for the language-generic program reducers to further                reduce the programs.                Our thorough evaluation on 50 benchmarks across three programming                languages (i.e., C, Rust and JavaScript) has demonstrated                LPR\u2019s practicality and superiority over Vulcan, the state-of-the-art                language-generic program reducer. For effectiveness, LPR surpasses                Vulcan by producing 24.93\\%, 4.47\\%, and 11.71\\% smaller programs                on benchmarks in C, Rust and JavaScript, separately. Moreover, LPR                and Vulcan have the potential to complement each other. For the C                language for which C-Reduce is optimized, by applying Vulcan to                the output produced by LPR, we can attain program sizes that are                on par with those achieved by C-Reduce. For efficiency perceived                by users, LPR is more efficient when reducing large and complex                programs, taking 10.77\\%, 34.88\\%, 36.96\\% less time than Vulcan to                finish all the benchmarks in C, Rust and JavaScript, separately.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "261\u2013273",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program transformation",
            "program testing",
            "debugging"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Automating Zero-Shot Patch Porting for Hard Forks": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652134",
        "author": "Pan, Shengyi and Wang, You and Liu, Zhongxin and Hu, Xing and Xia, Xin and Li, Shanping",
        "title": "Automating Zero-Shot Patch Porting for Hard Forks",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652134",
        "doi": "10.1145/3650212.3652134",
        "abstract": "Forking is a typical way of code reuse, which provides a simple way for developers to create a variant software (denoted as hard fork) by copying and modifying an existing codebase. Despite of the benefits, forking also leads to duplicate efforts in software maintenance. Developers need to port patches across the hard forks to address similar bugs or implement similar features. Due to the divergence between the source project and the hard fork, patch porting is complicated, which requires an adaption regarding different implementations of the same functionality. In this work, we take the first step to automate patch porting for hard forks under a zero-shot setting. We first conduct an empirical study of the patches ported from Vim to Neovim over the last ten years to investigate the necessities of patch porting and the potential flaws in the current practice. We then propose a large language model (LLM) based approach (namely PPatHF) to automatically port patches for hard forks on a function-wise basis. Specifically, PPatHF is composed of a reduction module and a porting module. Given the pre- and post-patch versions of a function from the reference project and the corresponding function from the target project, the reduction module first slims the input functions by removing code snippets less relevant to the patch. Then, the porting module leverages a LLM to apply the patch to the function from the target project. To better elicit the power of the LLM on patch porting, we design a prompt template to enable efficient in-context learning. We further propose an instruction-tuning based training task to better guide the LLM to port the patch and inject task-specific knowledge. We evaluate PPatHF on 310 Neovim patches ported from Vim. The experimental results show that PPatHF outperforms the baselines significantly. Specifically, PPatHF can correctly port 131 (42.3\\%) patches and automate 57\\% of the manual edits required for the developer to port the patch.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "363\u2013375",
        "numpages": "13",
        "keywords": [
            "software maintenance and deployment",
            "empirical study"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Benchmarking Automated Program Repair: An Extensive Study on Both Real-World and Artificial Bugs": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652140",
        "author": "Ouyang, Yicheng and Yang, Jun and Zhang, Lingming",
        "title": "Benchmarking Automated Program Repair: An Extensive Study on Both Real-World and Artificial Bugs",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652140",
        "doi": "10.1145/3650212.3652140",
        "abstract": "As bugs are inevitable and prevalent in real-world programs, many Automated Program Repair (APR) techniques have been proposed to generate patches for them. However, due to the lack of a standard for evaluating APR techniques, prior works tend to use different settings and benchmarks in evaluation, threatening the trustworthiness of the evaluation results. Additionally, they typically only adopt plausibility and genuineness as evaluation metrics, which may potentially mask some underlying issues in APR techniques. To overcome these issues, in this paper, we conduct an extensive and multi-dimensional evaluation of nine learning-based and three traditional state-of-the-art APR techniques under the same environment and settings. We employ the widely studied Defects4J V2.0.0 benchmark and a newly constructed large-scale mutation-based benchmark named MuBench, derived from Defects4J and including 1,700 artificial bugs generated by various mutators, to uncover potential limitations in these APR techniques. We also apply multi-dimensional metrics, including compilability/plausibility/genuineness metrics, as well as SYE (SYntactic Equivalence) and TCE (Trivial Compiler Equivalence) metrics, to thoroughly analyze the 1,814,652 generated patches. This paper presents noteworthy findings from the extensive evaluation: Firstly, Large Language Model (LLM) based APR demonstrates less susceptibility to overfitting on the Defects4J V1.2.0 dataset and fixes the most number of bugs. Secondly, the study suggests a promising future for combining traditional and learning-based APR techniques, as they exhibit complementary advantages in fixing different types of bugs. Additionally, this work highlights the necessity for further enhancing patch compilability of learning-based APR techniques, despite the presence of various existing strategies attempting to improve it. The study also reveals other guidelines for enhancing APR techniques, including the need for handling unresolvable symbol compilability issues and reducing duplicate/no-op patch generation. Finally, our study uncovers seven implementation issues in the studied techniques, with five of them confirmed and fixed by the corresponding authors.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "440\u2013452",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair",
            "benchmark"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "CoEdPilot: Recommending Code Edits with Learned Prior Edit Relevance, Project-wise Awareness, and Interactive Nature": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3652142",
        "author": "Liu, Chenyan and Cai, Yufan and Lin, Yun and Huang, Yuhuan and Pei, Yunrui and Jiang, Bo and Yang, Ping and Dong, Jin Song and Mei, Hong",
        "title": "CoEdPilot: Recommending Code Edits with Learned Prior Edit Relevance, Project-wise Awareness, and Interactive Nature",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3652142",
        "doi": "10.1145/3650212.3652142",
        "abstract": "Recent years have seen the development of LLM-based code generation. Compared to generating code in a software project, incremental code edits are empirically observed to be more frequent. The emerging code editing approaches usually formulate the problem as generating an edit based on known relevant prior edits and context. However, practical code edits can be more complicated. First, an editing session can include multiple (ir)relevant edits to the code under edit. Second, the inference of the subsequent edits is non-trivial as the scope of its ripple effect can be the whole project.        In this work, we propose CoEdPilot, an LLM-driven solution to recommend code edits by discriminating the relevant edits, exploring their interactive natures, and estimating its ripple effect in the project. Specifically, CoEdPilot orchestrates multiple neural transformers to identify what and how to edit in the project regarding both edit location and edit content. When a user accomplishes an edit with an optional editing description, an Subsequent Edit Analysis first reports the most relevant files in the project with what types of edits (e.g., keep, insert, and replace) can happen for each line of their code. Next, an Edit-content Generator generates concrete edit options for the lines of code, regarding its relevant prior changes reported by an Edit-dependency Analyzer. Last, both the Subsequent Edit Analysis and the Edit-content Generator capture relevant prior edits as feedback to readjust their recommendations. We train our models by collecting over 180K commits from 471 open-source projects in 5 programming languages. Our extensive experiments show that (1) CoEdPilot can well predict the edits (i.e., predicting edit location with accuracy of 70.8\\%-85.3\\%, and the edit content with exact match rate of 41.8\\% and BLEU4 score of 60.7); (2) CoEdPilot can well boost existing edit generators such as GRACE and CCT5 on exact match rate by 8.57\\% points and BLEU4 score by 18.08. Last, our user study on 18 participants with 3 editing tasks (1) shows that CoEdPilot can be effective in assisting users to edit code in comparison with Copilot, and (2) sheds light on the future improvement of the tool design. The video demonstration of our tool is available at https://sites.google.com/view/coedpilot/home.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "466\u2013478",
        "numpages": "13",
        "keywords": [
            "code generation",
            "code completion",
            "code model training",
            "source code model"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Oracle-Guided Program Selection from Large Language Models": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680308",
        "author": "Fan, Zhiyu and Ruan, Haifeng and Mechtaev, Sergey and Roychoudhury, Abhik",
        "title": "Oracle-Guided Program Selection from Large Language Models",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680308",
        "doi": "10.1145/3650212.3680308",
        "abstract": "While large language models (LLMs) have shown significant advancements in code generation, their susceptibility to producing incorrect code poses a significant challenge to the adoption of LLM-generated programs. This issue largely stems from the reliance on natural language descriptions as informal oracles in code generation. Current strategies to mitigate this involve selecting the best program from multiple LLM-generated alternatives, judged by criteria like the consistency of their execution results on an LLM-generated test suite. However, this approach has crucial limitations: (1) LLMs often generate redundant tests or tests that cannot distinguish between correct and incorrect solutions, (2) the used consistency criteria, such as the majority vote, fail to foster developer trust due to the absence of transparent rationale behind the made choices. In this work, we propose a new perspective on increasing the quality of LLM-generated code via program selection using the LLM as a test oracle. Our method is based on our experimentally confirmed observation that LLMs serve more effectively as oracles when tasked with selecting the correct output from multiple choices. Leveraging this insight, we first generate distinguishing inputs that capture semantic discrepancies of programs sampled from an LLM, and record outputs produced by the programs on these inputs. An LLM then selects the most likely to be correct output from these, guided by the natural language problem description. We implemented this idea in a tool LLMCodeChoice and evaluated its accuracy in generating and selecting standalone programs. Our experiments demonstrated its effectiveness in improving pass@1 by 3.6-7\\% on HumanEval and MBPP benchmarks compared to the state-of-art CodeT. Most interestingly, the selected input-output specifications helped us to uncover incompleteness and ambiguities in task descriptions and also identify incorrect ground-truth implementations in the benchmarks.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "628\u2013640",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Automated Program Repair via Conversation: Fixing 162 out of 337 Bugs for $0.42 Each using ChatGPT": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680323",
        "author": "Xia, Chunqiu Steven and Zhang, Lingming",
        "title": "Automated Program Repair via Conversation: Fixing 162 out of 337 Bugs for $0.42 Each using ChatGPT",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680323",
        "doi": "10.1145/3650212.3680323",
        "abstract": "Automated Program Repair (APR) aims to automatically generate patches for buggy programs. Traditional APR techniques suffer from a lack of patch variety as they rely heavily on handcrafted or mined bug fixing patterns and cannot easily generalize to other bug/fix types. To address this limitation, recent APR work has been focused on leveraging modern Large Language Models (LLMs) to directly generate patches for APR. Such LLM-based APR tools work by first constructing an input prompt built using the original buggy code and then querying the LLM to either fill-in (cloze-style APR) the correct code at the bug location or to produce a completely new code snippet as the patch. While the LLM-based APR tools are able to achieve state-of-the-art results, they still follow the classic Generate and Validate (GV) repair paradigm of first generating lots of patches by sampling from the same initial prompt and then validating each one afterwards. This not only leads to many repeated patches that are incorrect, but also misses the crucial and yet previously ignored information in test failures as well as in plausible patches.        To address these aforementioned limitations, we propose ChatRepair, the first fully automated conversation-driven APR approach that interleaves patch generation with instant feedback to perform APR in a conversational style. ChatRepair first feeds the LLM with relevant test failure information to start with, and then learns from both failures and successes of earlier patching attempts of the same bug for more powerful APR. For earlier patches that failed to pass all tests, we combine the incorrect patches with their corresponding relevant test failure information to construct a new prompt for the LLM to generate the next patch. In this way, we can avoid making the same    mistakes. For earlier patches that passed all the tests (i.e., plausible patches), we further ask the LLM to generate alternative variations of the original plausible patches. In this way, we can further build on and learn from earlier successes to generate more plausible patches to increase the chance of having correct patches. While our approach is general, we implement ChatRepair using state-of-the-art dialogue-based LLM \u2013 ChatGPT. Our evaluation on the widely studied Defects4j dataset shows that ChatRepair is able to achieve the new state-of-the-art in repair performance, achieving 114 and 48 correct fixes on Defects4j 1.2 and 2.0 respectively. By calculating the cost    of accessing ChatGPT, we can fix 162 out of 337 bugs for $0.42 each!",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "819\u2013831",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "CREF: An LLM-Based Conversational Software Repair Framework for Programming Tutors": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680328",
        "author": "Yang, Boyang and Tian, Haoye and Pian, Weiguo and Yu, Haoran and Wang, Haitao and Klein, Jacques and Bissyand\\'{e}, Tegawend\\'{e} F. and Jin, Shunfu",
        "title": "CREF: An LLM-Based Conversational Software Repair Framework for Programming Tutors",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680328",
        "doi": "10.1145/3650212.3680328",
        "abstract": "With the proven effectiveness of Large Language Models (LLMs) in code-related tasks, researchers have explored their potential for program repair. However, existing repair benchmarks might have influenced LLM training data, potentially causing data leakage. To evaluate LLMs\u2019 realistic repair capabilities, (i) we introduce an extensive, non-crawled benchmark TutorCode, comprising 1,239 C++ defect codes and associated information such as tutor guidance, solution description, failing test cases, and the corrected code. Our work assesses LLM\u2019s repair performance on TutorCode, measuring repair correctness (TOP-5 and AVG-5) and patch precision (RPSR). (ii) We then provide a comprehensive investigation into which types of extra information can help LLMs improve their repair performance. Among these types, tutor guidance was the most effective information. To fully harness LLMs\u2019 conversational capabilities and the benefits of augmented information, (iii) we introduce a novel conversational semi-automatic repair framework CREF assisting human programming tutors. It demonstrates a remarkable AVG-5 improvement of 17.2\\%-24.6\\% compared to the baseline, achieving an impressive AVG-5 of 76.6\\% when utilizing GPT-4. These results highlight the potential for enhancing LLMs\u2019 repair capabilities through tutor interactions and historical conversations. The successful application of CREF in a real-world educational setting demonstrates its effectiveness in reducing tutors\u2019 workload and improving students\u2019 learning experience, showing promise for code review and other software engineering tasks.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "882\u2013894",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "When to Stop? Towards Efficient Code Generation in LLMs with Excess Token Prevention": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680343",
        "author": "Guo, Lianghong and Wang, Yanlin and Shi, Ensheng and Zhong, Wanjun and Zhang, Hongyu and Chen, Jiachi and Zhang, Ruikai and Ma, Yuchi and Zheng, Zibin",
        "title": "When to Stop? Towards Efficient Code Generation in LLMs with Excess Token Prevention",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680343",
        "doi": "10.1145/3650212.3680343",
        "abstract": "Code generation aims to automatically generate code snippets that meet given natural language requirements and plays an important role in software development. Although Code LLMs have shown excellent performance in this domain, their long generation time poses a signification limitation in practice use. In this paper, we first conduct an in-depth preliminary study with different Code LLMs on code generation task and identify a significant efficiency issue, i.e., continual generation of excess tokens. It harms the developer productivity and leads to huge computational wastes. To address it, we introduce CodeFast, an inference acceleration approach for Code LLMs on code generation. The key idea of CodeFast is to terminate the inference process in time when unnecessary excess tokens are detected. First, we propose an automatic data construction framework to obtain training data. Then, we train a unified lightweight model GenGuard applicable to multiple programming languages to predict whether to terminate inference at the current step. Finally, we enhance Code LLM with GenGuard to accelerate its inference in code generation task. We conduct extensive experiments with CodeFast on five representative Code LLMs across four widely used code generation datasets. Experimental results show that (1) CodeFast can significantly improve the inference speed of various Code LLMs in code generation, ranging form 34\\% to 452\\%, without compromising the quality of generated code. (2) CodeFast is stable across different parameter settings and can generalize to untrained datasets. Our code and data are available at https://github.com/DeepSoftwareAnalytics/CodeFast.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1073\u20131085",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "AI Coders Are among Us: Rethinking Programming Language Grammar towards Efficient Code Generation": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680347",
        "author": "Sun, Zhensu and Du, Xiaoning and Yang, Zhou and Li, Li and Lo, David",
        "title": "AI Coders Are among Us: Rethinking Programming Language Grammar towards Efficient Code Generation",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680347",
        "doi": "10.1145/3650212.3680347",
        "abstract": "Artificial Intelligence (AI) models have emerged as another important audience for programming languages alongside humans and machines, as we enter the era of large language models (LLMs). LLMs can now perform well in coding competitions and even write programs like developers to solve various tasks, including mathematical problems. However, the grammar and layout of current programs are designed to cater the needs of human developers -- with many grammar tokens and formatting tokens being used to make the code easier for humans to read. While this is helpful, such a design adds unnecessary computational work for LLMs, as each token they either use or produce consumes computational resources.               To improve inference efficiency and reduce computational costs, we propose the concept of AI-oriented grammar.This aims to represent code in a way that better suits the working mechanism of AI models. Code written with AI-oriented grammar discards formats and uses a minimum number of tokens to convey code semantics effectively. To demonstrate the feasibility of this concept, we explore and implement the first AI-oriented grammar for Python, named Simple Python (SimPy). SimPy is crafted by revising the original Python grammar through a series of heuristic rules. Programs written in SimPy maintain identical Abstract Syntax Tree (AST) structures to those in standard Python. This allows for not only execution via a modified AST parser, but also seamless transformation between programs written in Python and SimPy, enabling human developers and LLMs to use Python and SimPy, respectively, when they need to collaborate. We also look into methods to help existing LLMs understand and use SimPy effectively. In the experiments, compared with Python, SimPy enables a reduction in token usage by 13.5\\% and 10.4\\% for CodeLlama and GPT-4, respectively, when completing the same set of code-related tasks. Additionally, these models can maintain or even improve their performance when using SimPy instead of Python for these tasks. With these promising results, we call for further contributions to the development of AI-oriented program grammar within our community.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1124\u20131136",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680355",
        "author": "Zhang, Cen and Zheng, Yaowen and Bai, Mingqiang and Li, Yeting and Ma, Wei and Xie, Xiaofei and Li, Yuekang and Sun, Limin and Liu, Yang",
        "title": "How Effective Are They? Exploring Large Language Model Based Fuzz Driver Generation",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680355",
        "doi": "10.1145/3650212.3680355",
        "abstract": "Fuzz drivers are essential for library API fuzzing. However, automatically generating fuzz drivers is a complex task, as it demands the creation of high-quality, correct, and robust API usage code. An LLM-based (Large Language Model) approach for generating fuzz drivers is a promising area of research. Unlike traditional program analysis-based generators, this text-based approach is more generalized and capable of harnessing a variety of API usage information, resulting in code that is friendly for human readers. However, there is still a lack of understanding regarding the fundamental issues on this direction, such as its effectiveness and potential challenges.  To bridge this gap, we conducted the first in-depth study targeting the important issues of using LLMs to generate effective fuzz drivers. Our study features a curated dataset with 86 fuzz driver generation questions from 30 widely-used C projects. Six prompting strategies are designed and tested across five state-of-the-art LLMs with five different temperature settings. In total, our study evaluated 736,430 generated fuzz drivers, with 0.85 billion token costs ($8,000+ charged tokens). Additionally, we compared the LLM-generated drivers against those utilized in industry, conducting extensive fuzzing experiments (3.75 CPU-year). Our study uncovered that:  1) While LLM-based fuzz driver generation is a promising direction, it still encounters several obstacles towards practical applications; 2) LLMs face difficulties in generating effective fuzz drivers for APIs with intricate specifics. Three featured design choices of prompt strategies can be beneficial: issuing repeat queries, querying with examples, and employing an iterative querying process; 3) While LLM-generated drivers can yield fuzzing outcomes that are on par with those used in the industry, there are substantial opportunities for enhancement, such as extending contained API usage, or integrating semantic oracles to facilitate logical bug detection.  Our insights have been implemented to improve the OSS-Fuzz-Gen project, facilitating practical fuzz driver generation in industry.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1223\u20131235",
        "numpages": "13",
        "keywords": [
            "program testing",
            "fuzzing"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "ThinkRepair: Self-Directed Automated Program Repair": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680359",
        "author": "Yin, Xin and Ni, Chao and Wang, Shaohua and Li, Zhenhao and Zeng, Limin and Yang, Xiaohu",
        "title": "ThinkRepair: Self-Directed Automated Program Repair",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680359",
        "doi": "10.1145/3650212.3680359",
        "abstract": "Though many approaches have been proposed for Automated Program Repair (APR) and indeed achieved remarkable performance, they still have limitations in fixing bugs that require analyzing and reasoning about the logic of the buggy program. Recently, large language models (LLMs) instructed by prompt engineering have attracted much attention for their powerful ability to address many kinds of tasks including bug-fixing. However, the quality of the prompt will highly affect the ability of LLMs and manually constructing high-quality prompts is a costly endeavor.   To address this limitation, we propose a self-directed LLM-based automated program repair, ThinkRepair, with two main phases: collection phase and fixing phase. The former phase automatically collects various chains of thoughts that constitute pre-fixed knowledge by instructing LLMs with the Chain-of-Thought (CoT) prompt. The latter phase targets fixing a bug by first selecting examples for few-shot learning and second automatically interacting with LLMs, optionally appending with feedback of testing information.   Evaluations on two widely studied datasets (Defects4J and QuixBugs) by comparing ThinkRepair with 12 SOTA APRs indicate the priority of ThinkRepair in fixing bugs. Notably, ThinkRepair fixes 98 bugs and improves baselines by 27\\%\u223c344.4\\% on Defects4J V1.2. On Defects4J V2.0, ThinkRepair fixes 12\u223c65 more bugs than the SOTA APRs. Additionally, ThinkRepair also makes a considerable improvement on QuixBugs (31 for Java and 21 for Python at most).",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1274\u20131286",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "SelfPiCo: Self-Guided Partial Code Execution with LLMs": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680368",
        "author": "Xue, Zhipeng and Gao, Zhipeng and Wang, Shaohua and Hu, Xing and Xia, Xin and Li, Shanping",
        "title": "SelfPiCo: Self-Guided Partial Code Execution with LLMs",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680368",
        "doi": "10.1145/3650212.3680368",
        "abstract": "Code executability plays a vital role in software debugging and testing (e.g., detecting runtime exceptions or assertion violations). However, code execution, especially partial or arbitrary code execution, is a non-trivial task due to missing definitions and complex third-party dependencies. To make partial code (such as code snippets posted on the web or code fragments deep inside complex software projects) executable, the existing study has proposed a machine learning model to predict the undefined element types and inject the pre-defined dummy values into execution. However, the performance of their tool is limited due to its simply designed dummy values and the inability to continue learning. In this paper, we design and implement a novel framework, named SelfPiCo (Self-Guided Partial Code Executor), to dynamically guide partial code execution by incorporating the open-source LLM (i.e., Code Llama) within an interactive loop. Particularly, SelfPiCo leverages few-shot in-context learning and chain-of-thought reasoning to elicit human knowledge and logical reasoning based on fine-tuning the Code Llama model. SelfPiCo continuously learns from code execution results and refines its predictions step after step. Our evaluations demonstrate that SelfPiCo can execute 72.7\\% and 83.3\\% of all lines in the open-source code and Stack Overflow snippets, outperforming the most recent state-of-the-art Lexecutor by 37.9\\% and 33.5\\%, respectively. Moreover, SelfPiCo successfully detected 18 and 33 runtime type error issues by executing the partial code from eight GitHub software projects and 43 Stack Overflow posts, demonstrating the practical usage and potential application of our framework in practice.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1389\u20131401",
        "numpages": "13",
        "keywords": [
            "static analysis",
            "execution prediction"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Neurosymbolic Repair of Test Flakiness": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680369",
        "author": "Chen, Yang and Jabbarvand, Reyhaneh",
        "title": "Neurosymbolic Repair of Test Flakiness",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680369",
        "doi": "10.1145/3650212.3680369",
        "abstract": "Test flakiness, a non-deterministic behavior of builds irrelevant to code changes, is a major and continuing impediment to deliver- ing reliable software. The very few techniques for the automated repair of test flakiness are specifically crafted to repair either Order- Dependent (OD) or Implementation-Dependent (ID) flakiness. They are also all symbolic approaches, i.e., they leverage program analy- sis to detect and repair known test flakiness patterns and root causes, failing to generalize. To bridge the gap, we propose FlakyDoctor, a neuro-symbolic technique that combines the power of LLMs\u2014 generalizability\u2014and program analysis\u2014soundness\u2014to fix different types of test flakiness. Our extensive evaluation using 873 confirmed flaky tests (332 OD and 541 ID) from 243 real-world projects demonstrates the ability of FlakyDoctor in repairing flakiness, achieving 57\\% (OD) and 59\\% (ID) success rate. Comparing to three alternative flakiness repair approaches, FlakyDoctor can repair 8\\% more ID tests than DexFix, 12\\% more OD flaky tests than ODRepair, and 17\\% more OD flaky tests than iFixFlakies. Regardless of underlying LLM, the non-LLM components of FlakyDoctor contribute to 12\u201331 \\% of the overall performance, i.e., while part of the FlakyDoctor power is from using LLMs, they are not good enough to repair flaky tests in real-world projects alone. What makes the proposed technique superior to related research on test flakiness mitigation specifically and program repair, in general, is repairing 79 previously unfixed flaky tests in real-world projects. We opened pull requests for all cases with corresponding patches; 19 of them were accepted and merged at the time of submission.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1402\u20131414",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "CoSec: On-the-Fly Security Hardening of Code LLMs via Supervised Co-decoding": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680371",
        "author": "Li, Dong and Yan, Meng and Zhang, Yaosheng and Liu, Zhongxin and Liu, Chao and Zhang, Xiaohong and Chen, Ting and Lo, David",
        "title": "CoSec: On-the-Fly Security Hardening of Code LLMs via Supervised Co-decoding",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680371",
        "doi": "10.1145/3650212.3680371",
        "abstract": "Large Language Models (LLMs) specialized in code have shown exceptional proficiency across various programming-related tasks, particularly code generation. Nonetheless, due to its nature of pretraining on massive uncritically filtered data, prior studies have shown that code LLMs are prone to generate code with potential vulnerabilities. Existing approaches to mitigate this risk involve crafting data without vulnerability and subsequently retraining or fine-tuning the model. As the number of parameters exceeds a billion, the computation and data demands of the above approaches will be enormous. Moreover, an increasing number of code LLMs tend to be distributed as services, where the internal representation is not accessible, and the API is the only way to reach the LLM, making the prior mitigation strategies non-applicable.    To cope with this, we propose CoSec, an on-the-fly Security hardening method of code LLMs based on security model-guided Co-decoding, to reduce the likelihood of code LLMs to generate code containing vulnerabilities. Our key idea is to train a separate but much smaller security model to co-decode with a target code LLM. Since the trained secure model has higher confidence for secure tokens, it guides the generation of the target base model towards more secure code generation. By adjusting the probability distributions of tokens during each step of the decoding process, our approach effectively influences the tendencies of generation without accessing the internal parameters of the target code LLM. We have conducted extensive experiments across various parameters in multiple code LLMs (i.e., CodeGen, StarCoder, and DeepSeek-Coder), and the results show that our approach is effective in security hardening. Specifically, our approach improves the average security ratio of six base models by 5.02\\%-37.14\\%, while maintaining the functional correctness of the target model.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1428\u20131439",
        "numpages": "12",
        "keywords": [
            "code model security",
            "defense"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "One-to-One or One-to-Many? Suggesting Extract Class Refactoring Opportunities with Intra-class Dependency Hypergraph Neural Network": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680379",
        "author": "Cui, Di and Wang, Qiangqiang and Zhao, Yutong and Wang, Jiaqi and Wei, Minjie and Hu, Jingzhao and Wang, Luqiao and Li, Qingshan",
        "title": "One-to-One or One-to-Many? Suggesting Extract Class Refactoring Opportunities with Intra-class Dependency Hypergraph Neural Network",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680379",
        "doi": "10.1145/3650212.3680379",
        "abstract": "Excessively large classes that encapsulate multiple responsibilities are challenging to comprehend and maintain. Addressing this issue, several Extract Class refactoring tools have been proposed, employing a two-phase process: identifying suitable fields or methods for extraction, and implementing the mechanics of refactoring. These tools traditionally generate an intra-class dependency graph to analyze the class structure, applying hard-coded rules based on this graph to unearth refactoring opportunities. Yet, the graph-based approach predominantly illuminates direct, \u201cone-to-one\u201d relationship between pairwise entities. Such a perspective is restrictive as it overlooks the complex, \u201cone-to-many\u201d dependencies among multiple entities that are prevalent in real-world classes. This narrow focus can lead to refactoring suggestions that may diverge from developers\u2019 actual needs, given their multifaceted nature. To bridge this gap, our paper leverages the concept of intra-class dependency hypergraph to model one-to-many dependency relationship and proposes a hypergraph learning-based approach to suggest Extract Class refactoring opportunities named HECS. For each target class, we first construct its intra-class dependency hypergraph and assign attributes to nodes with a pre-trained code model. All the attributed hypergraphs are fed into an enhanced hypergraph neural network for training. Utilizing this trained neural network alongside a large language model (LLM), we construct a refactoring suggestion system. We trained HECS on a large-scale dataset and evaluated it on two real-world datasets. The results show that demonstrates an increase of 38.5\\% in precision, 9.7\\% in recall, and 44.4\\% in f1-measure compared to 3 state-of-the-art refactoring tools including JDeodorant, SSECS, and LLMRefactor, which is more useful for 64\\% of participants. The results also unveil practical suggestions and new insights that benefit existing extract-related refactoring techniques.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1529\u20131540",
        "numpages": "12",
        "keywords": [
            "code generation",
            "program transformation"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "AutoCodeRover: Autonomous Program Improvement": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680384",
        "author": "Zhang, Yuntong and Ruan, Haifeng and Fan, Zhiyu and Roychoudhury, Abhik",
        "title": "AutoCodeRover: Autonomous Program Improvement",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680384",
        "doi": "10.1145/3650212.3680384",
        "abstract": "Researchers have made significant progress in automating the software development process in the past decades. Automated techniques for issue summarization, bug reproduction, fault localization, and program repair have been built to ease the workload of developers. Recent progress in Large Language Models (LLMs) has significantly impacted the development process, where developers can use LLM-based programming assistants to achieve automated coding. Nevertheless, software engineering involves the process of program improvement apart from coding, specifically to enable software maintenance (e.g. program repair to fix bugs) and software evolution (e.g. feature additions). In this paper, we propose an automated approach for solving Github issues to autonomously achieve program improvement. In our approach called AutoCodeRover, LLMs are combined with sophisticated code search capabilities, ultimately leading to a program modification or patch. In contrast to recent LLM agent approaches from AI researchers and practitioners, our outlook is more software engineering oriented. We work on a program representation (abstract syntax tree) as opposed to viewing a software project as a mere collection of files. Our code search exploits the program structure in the form of classes/methods to enhance LLM\u2019s understanding of the issue\u2019s root cause, and effectively retrieve a context via iterative search. The use of spectrum-based fault localization using tests, further sharpens the context, as long as a test-suite is available. Experiments on the recently proposed SWE-bench-lite (300 real-life Github issues) show increased efficacy in solving Github issues (19\\% on SWE-bench-lite), which is higher than the efficacy of the recently reported Swe-agent. Interestingly, our approach resolved 57 GitHub issues in about 4 minutes each (pass@1), whereas developers spent more than 2.68 days on average. In addition, AutoCodeRover achieved this efficacy with significantly lower cost (on average, $0.43 USD), compared to other baselines. We posit that our workflow enables autonomous software engineering, where, in future, auto-generated code from LLMs can be autonomously improved.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1592\u20131604",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "LLM4Fin: Fully Automating LLM-Powered Test Case Generation for FinTech Software Acceptance Testing": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680388",
        "author": "Xue, Zhiyi and Li, Liangguo and Tian, Senyue and Chen, Xiaohong and Li, Pingping and Chen, Liangyu and Jiang, Tingting and Zhang, Min",
        "title": "LLM4Fin: Fully Automating LLM-Powered Test Case Generation for FinTech Software Acceptance Testing",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680388",
        "doi": "10.1145/3650212.3680388",
        "abstract": "FinTech software, crucial for both safety and timely market deployment, presents a compelling case for automated acceptance testing against regulatory business rules. However, the inherent challenges of comprehending unstructured natural language descriptions of these rules and crafting comprehensive test cases demand human intelligence. The emergence of Large Language Models (LLMs) holds promise for automated test case generation, leveraging their natural language processing capabilities. Yet, their dependence on human intervention for effective prompting hampers efficiency.    In response, we introduce a groundbreaking, fully automated approach for generating high-coverage test cases from natural language business rules. Our methodology seamlessly integrates the versatility of LLMs with the predictability of algorithmic methods. We fine-tune pre-trained LLMs for improved information extraction accuracy and algorithmically generate comprehensive testable scenarios for the extracted business rules.\tOur prototype, LLM4Fin, is designed for testing real-world stock-trading software. Experimental results demonstrate LLM4Fin\u2019s superiority over both state-of-the-art LLM, such as ChatGPT, and skilled testing engineers. We achieve remarkable performance, with up to 98.18\\% and an average of 20\\%\u2212110\\% improvement on business scenario coverage, and up to 93.72\\% on code coverage, while reducing the time cost from 20 minutes to a mere 7 seconds. These results provide robust evidence of the framework\u2019s practical applicability and efficiency, marking a significant advancement in FinTech software testing.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1643\u20131655",
        "numpages": "13",
        "keywords": [
            "program testing"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Fuzzing JavaScript Interpreters with Coverage-Guided Reinforcement Learning for LLM-Based Mutation": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680389",
        "author": "Eom, Jueon and Jeong, Seyeon and Kwon, Taekyoung",
        "title": "Fuzzing JavaScript Interpreters with Coverage-Guided Reinforcement Learning for LLM-Based Mutation",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680389",
        "doi": "10.1145/3650212.3680389",
        "abstract": "JavaScript interpreters, crucial for modern web browsers, require an effective fuzzing method to identify security-related bugs. However, the strict grammatical requirements for input present significant challenges. Recent efforts to integrate language models for context- aware mutation in fuzzing are promising but lack the necessary coverage guidance to be fully effective. This paper presents a novel technique called CovRL (Coverage-guided Reinforcement Learning) that combines Large Language Models (LLMs) with Reinforcement Learning (RL) from coverage feedback. Our fuzzer, CovRL-Fuzz, integrates coverage feedback directly into the LLM by leveraging the Term Frequency-Inverse Document Frequency (TF-IDF) method to construct a weighted coverage map. This map is key in calculating the fuzzing reward, which is then applied to the LLM-based mutator through reinforcement learning. CovRL-Fuzz, through this approach, enables the generation of test cases that are more likely to discover new coverage areas, thus improving bug detection while minimizing syntax and semantic errors, all without needing extra post-processing. Our evaluation results show that CovRL-Fuzz outperforms the state-of-the-art fuzzers in enhancing code coverage and identifying bugs in JavaScript interpreters: CovRL-Fuzz identified 58 real-world security-related bugs in the latest JavaScript interpreters, including 50 previously unknown bugs and 15 CVEs.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1656\u20131668",
        "numpages": "13",
        "keywords": [
            "program testing",
            "fuzzing",
            "compiler testing"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Large Language Models for Equivalent Mutant Detection: How Far Are We?": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680395",
        "author": "Tian, Zhao and Shu, Honglin and Wang, Dong and Cao, Xuejie and Kamei, Yasutaka and Chen, Junjie",
        "title": "Large Language Models for Equivalent Mutant Detection: How Far Are We?",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680395",
        "doi": "10.1145/3650212.3680395",
        "abstract": "Mutation testing is vital for ensuring software quality. However, the presence of equivalent mutants is known to introduce redundant cost and bias issues, hindering the effectiveness of mutation testing in practical use. Although numerous equivalent mutant detection (EMD) techniques have been proposed, they exhibit limitations due to the scarcity of training data and challenges in generalizing to unseen mutants. Recently, large language models (LLMs) have been extensively adopted in various code-related tasks and have shown superior performance by more accurately capturing program semantics. Yet the performance of LLMs in equivalent mutant detection remains largely unclear. In this paper, we conduct an empirical study on 3,302 method-level Java mutant pairs to comprehensively investigate the effectiveness and efficiency of LLMs for equivalent mutant detection. Specifically, we assess the performance of LLMs compared to existing EMD techniques, examine the various strategies of LLMs, evaluate the orthogonality between EMD techniques, and measure the time overhead of training and inference. Our findings demonstrate that LLM-based techniques significantly outperform existing techniques (i.e., the average improvement of 35.69\\% in terms of F1-score), with the fine-tuned code embedding strategy being the most effective. Moreover, LLM-based techniques offer an excellent balance between cost (relatively low training and inference time) and effectiveness. Based on our findings, we further discuss the impact of model size and embedding quality, and provide several promising directions for future research. This work is the first to examine LLMs in equivalent mutant detection, affirming their effectiveness and efficiency.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1733\u20131745",
        "numpages": "13",
        "keywords": [
            "program testing",
            "mutation testing",
            "empirical study"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Maltracker: A Fine-Grained NPM Malware Tracker Copiloted by LLM-Enhanced Dataset": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3680397",
        "author": "Yu, Zeliang and Wen, Ming and Guo, Xiaochen and Jin, Hai",
        "title": "Maltracker: A Fine-Grained NPM Malware Tracker Copiloted by LLM-Enhanced Dataset",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3680397",
        "doi": "10.1145/3650212.3680397",
        "abstract": "As the largest package registry, Node Package Manager (NPM) has become the prime target for various supply chain attacks recently and has been flooded with numerous malicious packages, posing significant security risks to end-users. Learning-based methods have demonstrated promising performance with good adaptability to various types of attacks. However, they suffer from two main limitations. First, they often utilize metadata features or coarse-grained code features extracted at the package level while overlooking complex code semantics. Second, the dataset used to train the model often suffers from a lack of variety both in quantity and diversity, and thus cannot detect significant types of attacks.      To address these problems, we introduce Maltracker, a learningbased NPM malware tracker based on fine-grained features empowered by LLM-enhanced dataset. First, Maltracker constructs precise call graphs to extract suspicious functions that are reachable to a pre-defined set of sensitive APIs, and then utilizes community detection algorithm to identify suspicious code gadgets based on program dependency graph, from which fine-grained features are then extracted. To address the second limitation, we extend the dataset using advanced large language models (LLM) to translate malicious functions from other languages (e.g., C/C++, Python, and Go) into JavaScript. Evaluations shows that Maltracker can achieve an improvement of about 12.6\\% in terms of F1-score at the package level and 31.0\\% at the function level compared with the SOTA learning-based methods. Moreover, the key components of \ud835\udc40\ud835\udc4e\ud835\udc59\ud835\udc61\ud835\udc5f\ud835\udc4e\ud835\udc50\ud835\udc58\ud835\udc52\ud835\udc5f all contribute to the effectiveness of its performance. Finally, Maltracker has also detected 230 new malicious packages in NPM and received 61 thanks letters, among which some contain new malicious behaviors that cannot be detected by existing tools.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1759\u20131771",
        "numpages": "13",
        "keywords": [
            "software maintenance and deployment",
            "supply chain"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "HECS: A Hypergraph Learning-Based System for Detecting Extract Class Refactoring Opportunities": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3685307",
        "author": "Wang, Luqiao and Wang, Qiangqiang and Wang, Jiaqi and Zhao, Yutong and Wei, Minjie and Quan, Zhou and Cui, Di and Li, Qingshan",
        "title": "HECS: A Hypergraph Learning-Based System for Detecting Extract Class Refactoring Opportunities",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3685307",
        "doi": "10.1145/3650212.3685307",
        "abstract": "HECS is an advanced tool designed for Extract Class refactoring by leveraging hypergraph learning to model complex dependencies within large classes. Unlike traditional tools that rely on direct one-to-one dependency graphs, HECS uses intra-class dependency hypergraphs to capture one-to-many relationships. This allows HECS to provide more accurate and relevant refactoring suggestions. The tool constructs hypergraphs for each target class, attributes nodes using a pre-trained code model, and trains an enhanced hypergraph neural network. Coupled with a large language model, HECS delivers practical refactoring suggestions. In evaluations on large-scale and real-world datasets, HECS achieved a 38.5\\% increase in precision, 9.7\\% in recall, and 44.4\\% in f1-measure compared to JDeodorant, SSECS, and LLMRefactor. These improvements make HECS a valuable tool for developers, offering practical insights and enhancing existing refactoring techniques.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1851\u20131855",
        "numpages": "5",
        "keywords": [
            "code generation",
            "program transformation"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "Collaboration to Repository-Level Vulnerability Detection": {
        "type": "inproceedings",
        "key": "10.1145/3650212.3685562",
        "author": "Wen, Xin-Cheng",
        "title": "Collaboration to Repository-Level Vulnerability Detection",
        "year": "2024",
        "isbn": "9798400706127",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3650212.3685562",
        "doi": "10.1145/3650212.3685562",
        "abstract": "Large Language Model (LLM)-based methods have proven to be effective for many software engineering domains, with a potential for substantial productivity effective for software vulnerability detection.    However, due to the limitation of the length of input contexts of LLM, the existing LLM-based methods mainly focus on detecting function-level and leveraging the in-file context information for vulnerability detection (i.e., intra-procedural vulnerabilities), ignoring the more complex inter-procedural vulnerability detection scenarios in practice.    For instance, in real-world scenarios, developers routinely engage with program analysis to detect vulnerabilities that span multiple cross-file information within repositories.       Since complex processes tend to have redundancy dependencies from spanning multiple files in the repository level and invoking multiple static analysis tools, the ideal goal of vulnerability detection is to extract the vulnerability-related information from the repository and provide potential possible explanations for vulnerability triggers.   However, such a goal is hard to achieve, and thus in this work, we design three works through multi-agent collaboration to approach the goal of repository-level vulnerability detection.",
        "booktitle": "Proceedings of the 33rd ACM SIGSOFT International Symposium on Software Testing and Analysis",
        "pages": "1926\u20131928",
        "numpages": "3",
        "keywords": [
            "code generation",
            "bug detection"
        ],
        "location": "Vienna, Austria",
        "series": "ISSTA 2024",
        "venue": "ISSTA2024"
    },
    "UniLog: Automatic Logging via LLM and In-Context Learning": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3623326",
        "author": "Xu, Junjielong and Cui, Ziang and Zhao, Yuan and Zhang, Xu and He, Shilin and He, Pinjia and Li, Liqun and Kang, Yu and Lin, Qingwei and Dang, Yingnong and Rajmohan, Saravan and Zhang, Dongmei",
        "title": "UniLog: Automatic Logging via LLM and In-Context Learning",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3623326",
        "doi": "10.1145/3597503.3623326",
        "abstract": "Logging, which aims to determine the position of logging statements, the verbosity levels, and the log messages, is a crucial process for software reliability enhancement. In recent years, numerous automatic logging tools have been designed to assist developers in one of the logging tasks (e.g., providing suggestions on whether to log in try-catch blocks). These tools are useful in certain situations yet cannot provide a comprehensive logging solution in general. Moreover, although recent research has started to explore end-to-end logging, it is still largely constrained by the high cost of fine-tuning, hindering its practical usefulness in software development. To address these problems, this paper proposes UniLog, an automatic logging framework based on the in-context learning (ICL) paradigm of large language models (LLMs). Specifically, UniLog can generate an appropriate logging statement with only a prompt containing five demonstration examples without any model tuning. In addition, UniLog can further enhance its logging ability after warmup with only a few hundred random samples. We evaluated UniLog on a large dataset containing 12,012 code snippets extracted from 1,465 GitHub repositories. The results show that UniLog achieved the state-of-the-art performance in automatic logging: (1) 76.9\\% accuracy in selecting logging positions, (2) 72.3\\% accuracy in predicting verbosity levels, and (3) 27.1 BLEU-4 score in generating log messages. Meanwhile, UniLog requires less than 4\\% of the parameter tuning time needed by fine-tuning the same LLM.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "14",
        "numpages": "12",
        "keywords": [
            "software maintenance and deployment",
            "system log analysis"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Dataflow Analysis-Inspired Deep Learning for Efficient Vulnerability Detection": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3623345",
        "author": "Steenhoek, Benjamin and Gao, Hongyang and Le, Wei",
        "title": "Dataflow Analysis-Inspired Deep Learning for Efficient Vulnerability Detection",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3623345",
        "doi": "10.1145/3597503.3623345",
        "abstract": "Deep learning-based vulnerability detection has shown great performance and, in some studies, outperformed static analysis tools. However, the highest-performing approaches use token-based transformer models, which are not the most efficient to capture code semantics required for vulnerability detection. Classical program analysis techniques such as dataflow analysis can detect many types of bugs based on their root causes. In this paper, we propose to combine such causal-based vulnerability detection algorithms with deep learning, aiming to achieve more efficient and effective vulnerability detection. Specifically, we designed DeepDFA, a dataflow analysis-inspired graph learning framework and an embedding technique that enables graph learning to simulate dataflow computation. We show that DeepDFA is both performant and efficient. DeepDFA outperformed all non-transformer baselines. It was trained in 9 minutes, 75x faster than the highest-performing baseline model. When using only 50+ vulnerable and several hundreds of total examples as training data, the model retained the same performance as 100\\% of the dataset. DeepDFA also generalized to real-world vulnerabilities in DbgBench; it detected 8.7 out of 17 vulnerabilities on average across folds and was able to distinguish between patched and buggy versions, while the highest-performing baseline models did not detect any vulnerabilities. By combining DeepDFA with a large language model, we surpassed the state-of-the-art vulnerability detection performance on the Big-Vul dataset with 96.46 F1 score, 97.82 precision, and 95.14 recall. Our replication package is located at https://doi.org/10.6084/m9.figshare.21225413.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "16",
        "numpages": "13",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "static analysis",
            "bug detection",
            "code model training",
            "source code model"
        ]
    },
    "Large Language Models for Test-Free Fault Localization": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3623342",
        "author": "Yang, Aidan Z. H. and Le Goues, Claire and Martins, Ruben and Hellendoorn, Vincent",
        "title": "Large Language Models for Test-Free Fault Localization",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3623342",
        "doi": "10.1145/3597503.3623342",
        "abstract": "Fault Localization (FL) aims to automatically localize buggy lines of code, a key first step in many manual and automatic debugging tasks. Previous FL techniques assume the provision of input tests, and often require extensive program analysis, program instrumentation, or data preprocessing. Prior work on deep learning for APR struggles to learn from small datasets and produces limited results on real-world programs. Inspired by the ability of large language models (LLMs) of code to adapt to new tasks based on very few examples, we investigate the applicability of LLMs to line level fault localization. Specifically, we propose to overcome the left-to-right nature of LLMs by fine-tuning a small set of bidirectional adapter layers on top of the representations learned by LLMs to produce LLMAO, the first language model based fault localization approach that locates buggy lines of code without any test coverage information. We fine-tune LLMs with 350 million, 6 billion, and 16 billion parameters on small, manually curated corpora of buggy programs such as the Defects4J corpus. We observe that our technique achieves substantially more confidence in fault localization when built on the larger models, with bug localization performance scaling consistently with the LLM size. Our empirical evaluation shows that LLMAO improves the Top-1 results over the state-of-the-art machine learning fault localization (MLFL) baselines by 2.3\\%--54.4\\%, and Top-5 results by 14.4\\%-35.6\\%. LLMAO is also the first FL technique trained using a language model architecture that can detect security vulnerabilities down to the code line level.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "17",
        "numpages": "12",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "program testing",
            "debugging",
            "code model training",
            "source code model"
        ]
    },
    "Large Language Models are Few-Shot Summarizers: Multi-Intent Comment Generation via In-Context Learning": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3608134",
        "author": "Geng, Mingyang and Wang, Shangwen and Dong, Dezun and Wang, Haotian and Li, Ge and Jin, Zhi and Mao, Xiaoguang and Liao, Xiangke",
        "title": "Large Language Models are Few-Shot Summarizers: Multi-Intent Comment Generation via In-Context Learning",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3608134",
        "doi": "10.1145/3597503.3608134",
        "abstract": "Code comment generation aims at generating natural language descriptions for a code snippet to facilitate developers' program comprehension activities. Despite being studied for a long time, a bottleneck for existing approaches is that given a code snippet, they can only generate one comment while developers usually need to know information from diverse perspectives such as what is the functionality of this code snippet and how to use it. To tackle this limitation, this study empirically investigates the feasibility of utilizing large language models (LLMs) to generate comments that can fulfill developers' diverse intents. Our intuition is based on the facts that (1) the code and its pairwise comment are used during the pre-training process of LLMs to build the semantic connection between the natural language and programming language, and (2) comments in the real-world projects, which are collected for the pre-training, usually contain different developers' intents. We thus postulate that the LLMs can already understand the code from different perspectives after the pre-training. Indeed, experiments on two large-scale datasets demonstrate the rationale of our insights: by adopting the in-context learning paradigm and giving adequate prompts to the LLM (e.g., providing it with ten or more examples), the LLM can significantly outperform a state-of-the-art supervised learning approach on generating comments with multiple intents. Results also show that customized strategies for constructing the prompts and post-processing strategies for reranking the results can both boost the LLM's performances, which shed light on future research directions for using LLMs to achieve comment generation.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "39",
        "numpages": "13",
        "keywords": [
            "software maintenance and deployment",
            "commit message generation"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Large Language Models are Edge-Case Generators: Crafting Unusual Programs for Fuzzing Deep Learning Libraries": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3623343",
        "author": "Deng, Yinlin and Xia, Chunqiu Steven and Yang, Chenyuan and Zhang, Shizhuo Dylan and Yang, Shujing and Zhang, Lingming",
        "title": "Large Language Models are Edge-Case Generators: Crafting Unusual Programs for Fuzzing Deep Learning Libraries",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3623343",
        "doi": "10.1145/3597503.3623343",
        "abstract": "Bugs in Deep Learning (DL) libraries may affect almost all downstream DL applications, and it is crucial to ensure the quality of such systems. It is challenging to generate valid input programs for fuzzing DL libraries, since the input programs need to satisfy both the syntax/semantics of the supported languages (e.g., Python) and the tensor/operator constraints for constructing valid computational graphs. Recently, the TitanFuzz work demonstrates that modern Large Language Models (LLMs) can be directly leveraged to implicitly learn all the language and DL computation constraints to generate valid programs for fuzzing DL libraries (and beyond). However, LLMs tend to generate ordinary programs following similar patterns/tokens with typical programs seen in their massive pre-training corpora (e.g., GitHub), while fuzzing favors unusual inputs that cover edge cases or are unlikely to be manually produced.To fill this gap, this paper proposes FuzzGPT, the first approach to priming LLMs to synthesize unusual programs for fuzzing. FuzzGPT is mainly built on the well-known hypothesis that historical bug-triggering programs may include rare/valuable code ingredients important for bug finding. Meanwhile, while traditional techniques leveraging such historical information require intensive human efforts to both design dedicated generators and ensure the syntactic/semantic validity of generated programs, FuzzGPT demonstrates that this process can be fully automated via the intrinsic capabilities of LLMs (including fine-tuning and in-context learning), while being generalizable and applicable to challenging domains. While FuzzGPT can be applied with different LLMs, this paper focuses on the powerful GPT-style models: Codex and CodeGen. Moreover, FuzzGPT also shows the potential of directly leveraging the instruction-following capability of the recent ChatGPT for effective fuzzing. The experimental study on two popular DL libraries (PyTorch and TensorFlow) shows that FuzzGPT can substantially outperform TitanFuzz, detecting 76 bugs, with 49 already confirmed as previously unknown bugs, including 11 high-priority bugs or security vulnerabilities.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "70",
        "numpages": "13",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "program testing",
            "fuzzing"
        ]
    },
    "On Extracting Specialized Code Abilities from Large Language Models: A Feasibility Study": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639091",
        "author": "Li, Zongjie and Wang, Chaozheng and Ma, Pingchuan and Liu, Chaowei and Wang, Shuai and Wu, Daoyuan and Gao, Cuiyun and Liu, Yang",
        "title": "On Extracting Specialized Code Abilities from Large Language Models: A Feasibility Study",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639091",
        "doi": "10.1145/3597503.3639091",
        "abstract": "Recent advances in large language models (LLMs) significantly boost their usage in software engineering. However, training a well-performing LLM demands a substantial workforce for data collection and annotation. Moreover, training datasets may be proprietary or partially open, and the process often requires a costly GPU cluster. The intellectual property value of commercial LLMs makes them attractive targets for imitation attacks, but creating an imitation model with comparable parameters still incurs high costs. This motivates us to explore a practical and novel direction: slicing commercial black-box LLMs using medium-sized backbone models.In this paper, we explore the feasibility of launching imitation attacks on LLMs to extract their specialized code abilities, such as \"code synthesis\" and \"code translation.\" We systematically investigate the effectiveness of launching code ability extraction attacks under different code-related tasks with multiple query schemes, including zero-shot, in-context, and Chain-of-Thought. We also design response checks to refine the outputs, leading to an effective imitation training process. Our results show promising outcomes, demonstrating that with a reasonable number of queries, attackers can train a medium-sized backbone model to replicate specialized code behaviors similar to the target LLMs. We summarize our findings and insights to help researchers better understand the threats posed by imitation attacks, including revealing a practical attack surface for generating adversarial code examples against LLMs.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "74",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "When Neural Code Completion Models Size up the Situation: Attaining Cheaper and Faster Completion through Dynamic Model Inference": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639120",
        "author": "Sun, Zhensu and Du, Xiaoning and Song, Fu and Wang, Shangwen and Li, Li",
        "title": "When Neural Code Completion Models Size up the Situation: Attaining Cheaper and Faster Completion through Dynamic Model Inference",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639120",
        "doi": "10.1145/3597503.3639120",
        "abstract": "Leveraging recent advancements in large language models, modern neural code completion models have demonstrated the capability to generate highly accurate code suggestions. However, their massive size poses challenges in terms of computational costs and environmental impact, hindering their widespread adoption in practical scenarios. Dynamic inference emerges as a promising solution, as it allocates minimal computation during inference while maintaining the model's performance. In this research, we explore dynamic inference within the context of code completion. Initially, we conducted an empirical investigation on GPT-2, focusing on the inference capabilities of intermediate layers for code completion. We found that 54.4\\% of tokens can be accurately generated using just the first layer, signifying significant computational savings potential. Moreover, despite using all layers, the model still fails to predict 14.5\\% of tokens correctly, and the subsequent completions continued from them are rarely considered helpful, with only a 4.2\\% Acceptance Rate. These findings motivate our exploration of dynamic inference in code completion and inspire us to enhance it with a decision-making mechanism that stops the generation of incorrect code. We thus propose a novel dynamic inference method specifically tailored for code completion models. This method aims not only to produce correct predictions with largely reduced computation but also to prevent incorrect predictions proactively. Our extensive evaluation shows that it can averagely skip 1.7 layers out of 16 layers in the models, leading to an 11.2\\% speedup with only a marginal 1.1\\% reduction in ROUGE-L.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "75",
        "numpages": "12",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "code generation",
            "code completion",
            "empirical study"
        ]
    },
    "Traces of Memorisation in Large Language Models for Code": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639133",
        "author": "Al-Kaswan, Ali and Izadi, Maliheh and van Deursen, Arie",
        "title": "Traces of Memorisation in Large Language Models for Code",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639133",
        "doi": "10.1145/3597503.3639133",
        "abstract": "Large language models have gained significant popularity because of their ability to generate human-like text and potential applications in various fields, such as Software Engineering. Large language models for code are commonly trained on large unsanitised corpora of source code scraped from the internet. The content of these datasets is memorised and can be extracted by attackers with data extraction attacks. In this work, we explore memorisation in large language models for code and compare the rate of memorisation with large language models trained on natural language. We adopt an existing benchmark for natural language and construct a benchmark for code by identifying samples that are vulnerable to attack. We run both benchmarks against a variety of models, and perform a data extraction attack. We find that large language models for code are vulnerable to data extraction attacks, like their natural language counterparts. From the training data that was identified to be potentially extractable we were able to extract 47\\% from a CodeGen-Mono-16B code completion model. We also observe that models memorise more, as their parameter count grows, and that their pre-training data are also vulnerable to attack. We also find that data carriers are memorised at a higher rate than regular code or documentation and that different model architectures memorise different samples. Data leakage has severe outcomes, so we urge the research community to further investigate the extent of this phenomenon using a wider range of models and extraction techniques in order to build safeguards to mitigate this issue.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "78",
        "numpages": "12",
        "keywords": [
            "code model security",
            "attack",
            "benchmark"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Evaluating Large Language Models in Class-Level Code Generation": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639219",
        "author": "Du, Xueying and Liu, Mingwei and Wang, Kaixin and Wang, Hanlin and Liu, Junwei and Chen, Yixuan and Feng, Jiayi and Sha, Chaofeng and Peng, Xin and Lou, Yiling",
        "title": "Evaluating Large Language Models in Class-Level Code Generation",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639219",
        "doi": "10.1145/3597503.3639219",
        "abstract": "Recently, many large language models (LLMs) have been proposed, showing advanced proficiency in code generation. Meanwhile, many efforts have been dedicated to evaluating LLMs on code generation benchmarks such as HumanEval. Although being very helpful for comparing different LLMs, existing evaluation focuses on a simple code generation scenario (i.e., function-level or statement-level code generation), which mainly asks LLMs to generate one single code unit (e.g., a function or a statement) for the given natural language description. Such evaluation focuses on generating independent and often small-scale code units, thus leaving it unclear how LLMs perform in real-world software development scenarios.To fill this knowledge gap, we make the first attempt to evaluate LLMs in a more challenging code generation scenario, i.e., class-level code generation. Compared with existing code generation benchmarks, it better reflects real-world software development scenarios due to it comprising broader contextual dependencies and multiple, interdependent units of code. We first manually construct the first class-level code generation benchmark ClassEval of 100 class-level Python code generation tasks with approximately 500 person-hours. Based on the new benchmark ClassEval, we then perform the first study of 11 state-of-the-art LLMs on class-level code generation. Based on our results, we find that all LLMs perform much worse on class-level code generation compared to the method-level. While GPT models still dominate other LLMs on class-level code generation, the performance rankings of other models on method-level code generation no longer holds for class-level code generation. Besides, most models (except GPT models) perform better when generating the class method by method; and they have the limited ability of generating dependent code. Based on our findings, we call for software engineering (SE) researchers' expertise to build more LLM benchmarks based on practical and complicated software development scenarios.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "81",
        "numpages": "13",
        "keywords": [
            "code generation",
            "benchmark"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Lost in Translation: A Study of Bugs Introduced by Large Language Models while Translating Code": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639226",
        "author": "Pan, Rangeet and Ibrahimzada, Ali Reza and Krishna, Rahul and Sankar, Divya and Wassi, Lambert Pouguem and Merler, Michele and Sobolev, Boris and Pavuluri, Raju and Sinha, Saurabh and Jabbarvand, Reyhaneh",
        "title": "Lost in Translation: A Study of Bugs Introduced by Large Language Models while Translating Code",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639226",
        "doi": "10.1145/3597503.3639226",
        "abstract": "Code translation aims to convert source code from one programming language (PL) to another. Given the promising abilities of large language models (LLMs) in code synthesis, researchers are exploring their potential to automate code translation. The prerequisite for advancing the state of LLM-based code translation is to understand their promises and limitations over existing techniques. To that end, we present a large-scale empirical study to investigate the ability of general LLMs and code LLMs for code translation across pairs of different languages, including C, C++, Go, Java, and Python. Our study, which involves the translation of 1,700 code samples from three benchmarks and two real-world projects, reveals that LLMs are yet to be reliably used to automate code translation---with correct translations ranging from 2.1\\% to 47.3\\% for the studied LLMs. Further manual investigation of unsuccessful translations identifies 15 categories of translation bugs. We also compare LLM-based code translation with traditional non-LLM-based approaches. Our analysis shows that these two classes of techniques have their own strengths and weaknesses. Finally, insights from our study suggest that providing more context to LLMs during translation can help them produce better results. To that end, we propose a prompt-crafting approach based on the symptoms of erroneous translations; this improves the performance of LLM-based code translation by 5.5\\% on average. Our study is the first of its kind, in terms of scale and breadth, that provides insights into the current limitations of LLMs in code translation and opportunities for improving them. Our dataset---consisting of 1,700 code samples in five PLs with 10K+ tests, 43K+ translated code, 1,748 manually labeled bugs, and 1,365 bug-fix pairs---can help drive research in this area.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "82",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program transformation",
            "empirical study"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Rust-lancet: Automated Ownership-Rule-Violation Fixing with Behavior Preservation": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639103",
        "author": "Yang, Wenzhang and Song, Linhai and Xue, Yinxing",
        "title": "Rust-lancet: Automated Ownership-Rule-Violation Fixing with Behavior Preservation",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639103",
        "doi": "10.1145/3597503.3639103",
        "abstract": "As a relatively new programming language, Rust is designed to provide both memory safety and runtime performance. To achieve this goal, Rust conducts rigorous static checks against its safety rules during compilation, effectively eliminating memory safety issues that plague C/C++ programs. Although useful, the safety rules pose programming challenges to Rust programmers, since programmers can easily violate safety rules when coding in Rust, leading their code to be rejected by the Rust compiler, a fact underscored by a recent user study. There exists a desire to automate the process of fixing safety-rule violations to enhance Rust's programmability.In this paper, we concentrate on Rust's ownership rules and develop rust-lancet to automatically fix their violations. We devise three strategies for altering code, each intended to modify a Rust program and make it pass Rust's compiler checks. Additionally, we introduce mental semantics to model the behaviors of Rust programs that cannot be compiled due to ownership-rule violations. We design an approach to verify whether modified programs preserve their original behaviors before patches are applied. We apply rust-lancet to 160 safety-rule violations from two sources, successfully fixing 102 violations under the optimal configuration --- more than rustc and six LLM-based techniques. Notably, rust-lancet avoids generating any incorrect patches, a distinction from all other baseline techniques. We also verify the effectiveness of each fixing strategy and behavior preservation validation and affirm the rationale behind these components.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "85",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program transformation"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "PyTy: Repairing Static Type Errors in Python": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639184",
        "author": "Chow, Yiu Wai and Di Grazia, Luca and Pradel, Michael",
        "title": "PyTy: Repairing Static Type Errors in Python",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639184",
        "doi": "10.1145/3597503.3639184",
        "abstract": "Gradual typing enables developers to annotate types of their own choosing, offering a flexible middle ground between no type annotations and a fully statically typed language. As more and more code bases get type-annotated, static type checkers detect an increasingly large number of type errors. Unfortunately, fixing these errors requires manual effort, hampering the adoption of gradual typing in practice. This paper presents PyTy, an automated program repair approach targeted at statically detectable type errors in Python. The problem of repairing type errors deserves specific attention because it exposes particular repair patterns, offers a warning message with hints about where and how to apply a fix, and because gradual type checking serves as an automatic way to validate fixes. We addresses this problem through three contributions: (i) an empirical study that investigates how developers fix Python type errors, showing a diverse set of fixing strategies with some recurring patterns; (ii) an approach to automatically extract type error fixes, which enables us to create a dataset of 2,766 error-fix pairs from 176 GitHub repositories, named PyTyDefects; (iii) the first learning-based repair technique for fixing type errors in Python. Motivated by the relative data scarcity of the problem, the neural model at the core of PyTy is trained via cross-lingual transfer learning. Our evaluation shows that PyTy offers fixes for ten frequent categories of type errors, successfully addressing 85.4\\% of 281 real-world errors. This effectiveness outperforms state-of-the-art large language models asked to repair type errors (by 2.1x) and complements a previous technique aimed at type errors that manifest at runtime. Finally, 20 out of 30 pull requests with PyTy-suggested fixes have been merged by developers, showing the usefulness of PyTy in practice.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "87",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair",
            "static analysis",
            "type inference"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Programming Assistant for Exception Handling with CodeBERT": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639188",
        "author": "Cai, Yuchen and Yadavally, Aashish and Mishra, Abhishek and Montejo, Genesis and Nguyen, Tien",
        "title": "Programming Assistant for Exception Handling with CodeBERT",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639188",
        "doi": "10.1145/3597503.3639188",
        "abstract": "With practical code reuse, the code fragments from developers' forums often migrate to applications. Owing to the incomplete nature of such fragments, they often lack the details on exception handling. The adaptation for exception handling to the codebase is not trivial as developers must learn and memorize what API methods could cause exceptions and what exceptions need to be handled. We propose Neurex, an exception handling recommender that learns from complete code, and accepts a given Java code snippet and recommends 1) if a try-catch block is needed, 2) what statements need to be placed in a try block, and 3) what exception types need to be caught in the catch clause. Inspired by the sequence chunking techniques in natural language processing, we design Neurex via a multi-tasking model with the fine-tuning of the large language model CodeBERT for these three exception handling recommendation tasks. Via the large language model, Neurex can learn the surrounding context, leading to better learning the dependencies among the API elements, and the relations between the statements and the corresponding exception types needed to be handled.Our empirical evaluation shows that Neurex correctly performs all three exception handling recommendation tasks in 71.5\\% of the cases with a F1-score of 70.2\\%, which is a relative improvement of 166\\% over the baseline. It achieves high F1-score from 98.2\\%-99.7\\% in try-catch block necessity checking (a relative improvement of up to 55.9\\% over the baselines). It also correctly decides both the need for try-catch block(s) and the statements to be placed in try blocks with the F1-scores of 74.7\\% and 87.1\\% at the instance and statement levels, an improvement of 129.1\\% and 44.9\\% over the baseline, respectively. Our extrinsic evaluation shows that Neurex relatively improves over the baseline by 56.5\\% in F1-score for detecting exception-related bugs in incomplete Android code snippets.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "94",
        "numpages": "13",
        "keywords": [
            "code generation",
            "program repair",
            "empirical study"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Using an LLM to Help With Code Understanding": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639187",
        "author": "Nam, Daye and Macvean, Andrew and Hellendoorn, Vincent and Vasilescu, Bogdan and Myers, Brad",
        "title": "Using an LLM to Help With Code Understanding",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639187",
        "doi": "10.1145/3597503.3639187",
        "abstract": "Understanding code is challenging, especially when working in new and complex development environments. Code comments and documentation can help, but are typically scarce or hard to navigate. Large language models (LLMs) are revolutionizing the process of writing code. Can they do the same for helping understand it? In this study, we provide a first investigation of an LLM-based conversational UI built directly in the IDE that is geared towards code understanding. Our IDE plugin queries OpenAI's GPT-3.5-turbo model with four high-level requests without the user having to write explicit prompts: to explain a highlighted section of code, provide details of API calls used in the code, explain key domain-specific terms, and provide usage examples for an API. The plugin also allows for open-ended prompts, which are automatically contextualized to the LLM with the program being edited. We evaluate this system in a user study with 32 participants, which confirms that using our plugin can aid task completion more than web search. We additionally provide a thorough analysis of the ways developers use, and perceive the usefulness of, our system, among others finding that the usage and benefits differ between students and professionals. We conclude that in-IDE prompt-less interaction with LLMs is a promising future direction for tool builders.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "97",
        "numpages": "13",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "software maintenance and deployment"
        ]
    },
    "Fuzz4All: Universal Fuzzing with Large Language Models": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639121",
        "author": "Xia, Chunqiu Steven and Paltenghi, Matteo and Le Tian, Jia and Pradel, Michael and Zhang, Lingming",
        "title": "Fuzz4All: Universal Fuzzing with Large Language Models",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639121",
        "doi": "10.1145/3597503.3639121",
        "abstract": "Fuzzing has achieved tremendous success in discovering bugs and vulnerabilities in various software systems. Systems under test (SUTs) that take in programming or formal language as inputs, e.g., compilers, runtime engines, constraint solvers, and software libraries with accessible APIs, are especially important as they are fundamental building blocks of software development. However, existing fuzzers for such systems often target a specific language, and thus cannot be easily applied to other languages or even other versions of the same language. Moreover, the inputs generated by existing fuzzers are often limited to specific features of the input language, and thus can hardly reveal bugs related to other or new features. This paper presents Fuzz4All, the first fuzzer that is universal in the sense that it can target many different input languages and many different features of these languages. The key idea behind Fuzz4All is to leverage large language models (LLMs) as an input generation and mutation engine, which enables the approach to produce diverse and realistic inputs for any practically relevant language. To realize this potential, we present a novel autoprompting technique, which creates LLM prompts that are well-suited for fuzzing, and a novel LLM-powered fuzzing loop, which iteratively updates the prompt to create new fuzzing inputs. We evaluate Fuzz4All on nine systems under test that take in six different languages (C, C++, Go, SMT2, Java, and Python) as inputs. The evaluation shows, across all six languages, that universal fuzzing achieves higher coverage than existing, language-specific fuzzers. Furthermore, Fuzz4All has identified 98 bugs in widely used systems, such as GCC, Clang, Z3, CVC5, OpenJDK, and the Qiskit quantum computing platform, with 64 bugs already confirmed by developers as previously unknown.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "126",
        "numpages": "13",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "program testing",
            "fuzzing"
        ]
    },
    "Sedar: Obtaining High-Quality Seeds for DBMS Fuzzing via Cross-DBMS SQL Transfer": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639210",
        "author": "Fu, Jingzhou and Liang, Jie and Wu, Zhiyong and Jiang, Yu",
        "title": "Sedar: Obtaining High-Quality Seeds for DBMS Fuzzing via Cross-DBMS SQL Transfer",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639210",
        "doi": "10.1145/3597503.3639210",
        "abstract": "Effective DBMS fuzzing relies on high-quality initial seeds, which serve as the starting point for mutation. These initial seeds should incorporate various DBMS features to explore the state space thoroughly. While built-in test cases are typically used as initial seeds, many DBMSs lack comprehensive test cases, making it difficult to apply state-of-the-art fuzzing techniques directly.To address this, we propose Sedar which produces initial seeds for a target DBMS by transferring test cases from other DBMSs. The underlying insight is that many DBMSs share similar functionalities, allowing seeds that cover deep execution paths in one DBMS to be adapted for other DBMSs. The challenge lies in converting these seeds to a format supported by the grammar of the target database. Sedar follows a three-step process to generate seeds. First, it executes existing SQL test cases within the DBMS they were designed for and captures the schema information during execution. Second, it utilizes large language models (LLMs) along with the captured schema information to guide the generation of new test cases based on the responses from the LLM. Lastly, to ensure that the test cases can be properly parsed and mutated by fuzzers, Sedar temporarily comments out unparsable sections for the fuzzers and uncomments them after mutation. We integrate Sedar into the DBMS fuzzers Sqirrel and Griffin, targeting DBMSs such as Virtuoso, MonetDB, DuckDB, and ClickHouse. Evaluation results demonstrate significant improvements in both fuzzers. Specifically, compared to Sqirrel and Griffin with non-transferred seeds, Sedar enhances code coverage by 72.46\\%-214.84\\% and 21.40\\%-194.46\\%; compared to Sqirrel and Griffin with native test cases of these DBMSs as initial seeds, incorporating the transferred seeds of Sedar results in an improvement in code coverage by 4.90\\%-16.20\\% and 9.73\\%-28.41\\%. Moreover, Sedar discovered 70 new vulnerabilities, with 60 out of them being uniquely found by Sedar with transferred seeds, and 19 of them have been assigned with CVEs.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "146",
        "numpages": "12",
        "keywords": [
            "program testing",
            "fuzzing",
            "DBMS testing"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639117",
        "author": "Sun, Yuqiang and Wu, Daoyuan and Xue, Yue and Liu, Han and Wang, Haijun and Xu, Zhengzi and Xie, Xiaofei and Liu, Yang",
        "title": "GPTScan: Detecting Logic Vulnerabilities in Smart Contracts by Combining GPT with Program Analysis",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639117",
        "doi": "10.1145/3597503.3639117",
        "abstract": "Smart contracts are prone to various vulnerabilities, leading to substantial financial losses over time. Current analysis tools mainly target vulnerabilities with fixed control- or data-flow patterns, such as re-entrancy and integer overflow. However, a recent study on Web3 security bugs revealed that about 80\\% of these bugs cannot be audited by existing tools due to the lack of domain-specific property description and checking. Given recent advances in Large Language Models (LLMs), it is worth exploring how Generative Pre-training Transformer (GPT) could aid in detecting logic vulnerabilities.In this paper, we propose GPTScan, the first tool combining GPT with static analysis for smart contract logic vulnerability detection. Instead of relying solely on GPT to identify vulnerabilities, which can lead to high false positives and is limited by GPT's pre-trained knowledge, we utilize GPT as a versatile code understanding tool. By breaking down each logic vulnerability type into scenarios and properties, GPTScan matches candidate vulnerabilities with GPT. To enhance accuracy, GPTScan further instructs GPT to intelligently recognize key variables and statements, which are then validated by static confirmation. Evaluation on diverse datasets with around 400 contract projects and 3K Solidity files shows that GPTScan achieves high precision (over 90\\%) for token contracts and acceptable precision (57.14\\%) for large projects like Web3Bugs. It effectively detects ground-truth logic vulnerabilities with a recall of over 70\\%, including 9 new vulnerabilities missed by human auditors. GPTScan is fast and cost-effective, taking an average of 14.39 seconds and 0.01 USD to scan per thousand lines of Solidity code. Moreover, static confirmation helps GPTScan reduce two-thirds of false positives.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "166",
        "numpages": "13",
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024",
        "keywords": [
            "static analysis",
            "bug detection"
        ]
    },
    "Where is it? Tracing the Vulnerability-relevant Files from Vulnerability Reports": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639202",
        "author": "Sun, Jiamou and Chen, Jieshan and Xing, Zhenchang and Lu, Qinghua and Xu, Xiwei and Zhu, Liming",
        "title": "Where is it? Tracing the Vulnerability-relevant Files from Vulnerability Reports",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639202",
        "doi": "10.1145/3597503.3639202",
        "abstract": "With the widely usage of open-source software, supply-chain-based vulnerability attacks, including SolarWind and Log4Shell, have posed significant risks to software security. Currently, people rely on vulnerability advisory databases or commercial software bill of materials (SBOM) to defend against potential risks. Unfortunately, these datasets do not provide finer-grained file-level vulnerability information, compromising their effectiveness. Previous works have not adequately addressed this issue, and mainstream vulnerability detection methods have their drawbacks that hinder resolving this gap. Driven by the real needs, we propose a framework that can trace the vulnerability-relevant file for each disclosed vulnerability. Our approach uses NVD descriptions with metadata as the inputs, and employs a series of strategies with a LLM model, search engine, heuristic-based text matching method and a deep learning classifier to recommend the most likely vulnerability-relevant file, effectively enhancing the completeness of existing NVD data. Our experiments confirm that the efficiency of the proposed framework, with CodeBERT achieving 0.92 AUC and 0.85 MAP, and our user study proves our approach can help with vulnerability-relevant file detection effectively. To the best of our knowledge, our work is the first one focusing on tracing vulnerability-relevant files, laying the groundwork of building finer-grained vulnerability-aware software bill of materials.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "200",
        "numpages": "13",
        "keywords": [
            "static analysis",
            "bug detection"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "Automatic Semantic Augmentation of Language Model Prompts (for Code Summarization)": {
        "type": "inproceedings",
        "key": "10.1145/3597503.3639183",
        "author": "Ahmed, Toufique and Pai, Kunal Suresh and Devanbu, Premkumar and Barr, Earl",
        "title": "Automatic Semantic Augmentation of Language Model Prompts (for Code Summarization)",
        "year": "2024",
        "isbn": "9798400702174",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "url": "https://doi.org/10.1145/3597503.3639183",
        "doi": "10.1145/3597503.3639183",
        "abstract": "Large Language Models (LLM) are a new class of computation engines, \"programmed\" via prompt engineering. Researchers are still learning how to best \"program\" these LLMs to help developers. We start with the intuition that developers tend to consciously and unconsciously collect semantics facts, from the code, while working. Mostly these are shallow, simple facts arising from a quick read. For a function, such facts might include parameter and local variable names, return expressions, simple pre- and post-conditions, and basic control and data flow, etc.One might assume that the powerful multi-layer architecture of transformer-style LLMs makes them implicitly capable of doing this simple level of \"code analysis\" and extracting such information, while processing code: but are they, really? If they aren't, could explicitly adding this information help? Our goal here is to investigate this question, using the code summarization task and evaluate whether automatically augmenting an LLM's prompt with semantic facts explicitly, actually helps.Prior work shows that LLM performance on code summarization benefits from embedding a few code \\&amp; summary exemplars in the prompt, before the code to be summarized. While summarization performance has steadily progressed since the early days, there is still room for improvement: LLM performance on code summarization still lags its performance on natural-language tasks like translation and text summarization.We find that adding semantic facts to the code in the prompt actually does help! This approach improves performance in several different settings suggested by prior work, including for three different Large Language Models. In most cases, we see improvements, as measured by a range of commonly-used metrics; for the PHP language in the challenging CodeSearchNet dataset, this augmentation actually yields performance surpassing 30 BLEU1. In addition, we have also found that including semantic facts yields a substantial enhancement in LLMs' line completion performance.",
        "booktitle": "Proceedings of the IEEE/ACM 46th International Conference on Software Engineering",
        "articleno": "220",
        "numpages": "13",
        "keywords": [
            "static analysis",
            "code summarization",
            "prompting strategy",
            "rag"
        ],
        "location": "Lisbon, Portugal",
        "series": "ICSE '24",
        "venue": "ICSE2024"
    },
    "LILAC: Log Parsing using LLMs with Adaptive Parsing Cache": {
        "type": "article",
        "key": "10.1145/3643733",
        "author": "Jiang, Zhihan and Liu, Jinyang and Chen, Zhuangbin and Li, Yichen and Huang, Junjie and Huo, Yintong and He, Pinjia and Gu, Jiazhen and Lyu, Michael R.",
        "title": "LILAC: Log Parsing using LLMs with Adaptive Parsing Cache",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643733",
        "doi": "10.1145/3643733",
        "abstract": "Log parsing transforms log messages into structured formats, serving as the prerequisite step for various log analysis tasks. Although a variety of log parsing approaches have been proposed, their performance on complicated log data remains compromised due to the use of human-crafted rules or learning-based models with limited training data. The recent emergence of powerful large language models (LLMs) demonstrates their vast pre-trained knowledge related to code and logging, making it promising to apply LLMs for log parsing. However, their lack of specialized log parsing capabilities currently hinders their parsing accuracy. Moreover, the inherent inconsistent answers, as well as the substantial overhead, prevent the practical adoption of LLM-based log parsing.   To address these challenges, we propose LILAC, the first practical Log parsIng framework using LLMs with Adaptive parsing Cache. To facilitate accurate and robust log parsing, LILAC leverages the in-context learning (ICL) capability of the LLM by performing a hierarchical candidate sampling algorithm and selecting high-quality demonstrations. Furthermore, LILAC incorporates a novel component, an adaptive parsing cache, to store and refine the templates generated by the LLM. It helps mitigate LLM's inefficiency issue by enabling rapid retrieval of previously processed log templates. In this process, LILAC adaptively updates the templates within the parsing cache to ensure the consistency of parsed results. The extensive evaluation on public large-scale datasets shows that LILAC outperforms state-of-the-art methods by 69.5\\% in terms of the average F1 score of template accuracy. In addition, LILAC reduces the query times to LLMs by several orders of magnitude, achieving a comparable efficiency to the fastest baseline.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "7",
        "numpages": "24",
        "keywords": [
            "software maintenance and deployment",
            "system log analysis"
        ],
        "venue": "FSE2024"
    },
    "DiffCoder: Enhancing Large Language Model on API Invocation via Analogical Code Exercises": {
        "type": "article",
        "key": "10.1145/3643745",
        "author": "Zan, Daoguang and Yu, Ailun and Shen, Bo and Chen, Bei and Li, Wei and Gong, Yongshun and Chen, Xiaolin and Yao, Yafen and Luo, Weihua and Guan, Bei and Liu, Yan and Wang, Yongji and Wang, Qianxiang and Cui, Lizhen",
        "title": "DiffCoder: Enhancing Large Language Model on API Invocation via Analogical Code Exercises",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643745",
        "doi": "10.1145/3643745",
        "abstract": "The task of code generation aims to generate code solutions based on given programming problems. Recently, code large language models (code LLMs) have shed new light on this task, owing to their formidable code generation capabilities. While these models are powerful, they seldom focus on further improving the accuracy of library-oriented API invocation. Nonetheless, programmers frequently invoke APIs in routine coding tasks. In this paper, we aim to enhance the proficiency of existing code LLMs regarding API invocation by mimicking analogical learning, which is a critical learning strategy for humans to learn through differences among multiple instances. Motivated by this, we propose a simple yet effective approach, namely DiffCoder, which excels in API invocation by effectively training on the differences (diffs) between analogical code exercises. To assess the API invocation capabilities of code LLMs, we conduct experiments on seven existing benchmarks that focus on mono-library API invocation. Additionally, we construct a new benchmark, namely PanNumEval, to evaluate the performance of multi-library API invocation. Extensive experiments on eight benchmarks demonstrate the impressive performance of DiffCoder. Furthermore, we develop a VSCode plugin for DiffCoder, and the results from twelve invited participants further verify the practicality of DiffCoder.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "19",
        "numpages": "21",
        "keywords": [
            "code generation",
            "code completion"
        ],
        "venue": "FSE2024"
    },
    "Natural Is the Best: Model-Agnostic Code Simplification for Pre-trained Large Language Models": {
        "type": "article",
        "key": "10.1145/3643753",
        "author": "Wang, Yan and Li, Xiaoning and Nguyen, Tien N. and Wang, Shaohua and Ni, Chao and Ding, Ling",
        "title": "Natural Is the Best: Model-Agnostic Code Simplification for Pre-trained Large Language Models",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643753",
        "doi": "10.1145/3643753",
        "abstract": "Pre-trained Large Language Models (LLM) have achieved remarkable successes in several domains. However, code-oriented LLMs are often heavy in computational complexity, and quadratically with the length of the input code sequence. Toward simplifying the input program of an LLM, the state-of-the-art approach has the strategies to filter the input code tokens based on the attention scores given by the LLM. The decision to simplify the input program should not rely on the attention patterns of an LLM, as these patterns are influenced by both the model architecture and the pre-training dataset. Since the model and dataset are part of the solution domain, not the problem domain where the input program belongs, the outcome may differ when the model is pre-trained on a different dataset. We propose SlimCode, a model-agnostic code simplification solution for LLMs that depends on the nature of input code tokens. As an empirical study on the LLMs including CodeBERT, CodeT5, and GPT-4 for two main tasks: code search and summarization, we reported that 1) the removal ratio of code has a linear-like relation with the saving ratio on training time, 2) the impact of categorized tokens on code simplification can vary significantly, 3) the impact of categorized tokens on code simplification is task-specific but model-agnostic, and 4) the above findings hold for the paradigm\u2013prompt engineering and interactive in-context learning. The empirical results showed that SlimCode can improve the state-of-the-art technique by 9.46\\% and 5.15\\% in terms of MRR and BLEU score on code search and summarization, respectively. More importantly, SlimCode is 133 times faster than the state-of-the-art approach. Additionally, SlimCode can reduce the cost of invoking GPT-4 by up to 24\\% per API query, while still producing comparable results to those with the original code. With this result, we call for a new direction on code-based, model-agnostic code simplification solutions to further empower LLMs.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "27",
        "numpages": "23",
        "keywords": [
            "code model training",
            "source code model"
        ],
        "venue": "FSE2024"
    },
    "Go Static: Contextualized Logging Statement Generation": {
        "type": "article",
        "key": "10.1145/3643754",
        "author": "Li, Yichen and Huo, Yintong and Zhong, Renyi and Jiang, Zhihan and Liu, Jinyang and Huang, Junjie and Gu, Jiazhen and He, Pinjia and Lyu, Michael R.",
        "title": "Go Static: Contextualized Logging Statement Generation",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643754",
        "doi": "10.1145/3643754",
        "abstract": "Logging practices have been extensively investigated to assist developers in writing appropriate logging statements for documenting software behaviors. Although numerous automatic logging approaches have been proposed, their performance remains unsatisfactory due to the constraint of the single-method input, without informative programming context outside the method. Specifically, we identify three inherent limitations with single-method context: limited static scope of logging statements, inconsistent logging styles, and missing type information of logging variables.                                To tackle these limitations, we propose SCLogger, the first contextualized logging statement generation approach with inter-method static contexts.First, SCLogger extracts inter-method contexts with static analysis to construct the contextualized prompt for language models to generate a tentative logging statement. The contextualized prompt consists of an extended static scope and sampled similar methods, ordered by the chain-of-thought (COT) strategy. Second, SCLogger refines the access of logging variables by formulating a new refinement prompt for language models, which incorporates detailed type information of variables in the tentative logging statement.                                The evaluation results show that SCLogger surpasses the state-of-the-art approach by 8.7\\% in logging position accuracy, 32.1\\% in level accuracy, 19.6\\% in variable precision, and 138.4\\% in text BLEU-4 score. Furthermore, SCLogger consistently boosts the performance of logging statement generation across a range of large language models, thereby showcasing the generalizability of this approach.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "28",
        "numpages": "22",
        "keywords": [
            "software maintenance and deployment",
            "system log analysis"
        ],
        "venue": "FSE2024"
    },
    "Unprecedented Code Change Automation: The Fusion of LLMs and Transformation by Example": {
        "type": "article",
        "key": "10.1145/3643755",
        "author": "Dilhara, Malinda and Bellur, Abhiram and Bryksin, Timofey and Dig, Danny",
        "title": "Unprecedented Code Change Automation: The Fusion of LLMs and Transformation by Example",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643755",
        "doi": "10.1145/3643755",
        "abstract": "Software developers often repeat the same code changes within a project or across different projects. These repetitive changes are known as \u201ccode change patterns\u201d (CPATs). Automating CPATs is crucial to expedite the software development process. While current Transformation by Example (TBE) techniques can automate CPATs, they are limited by the quality and quantity of the provided input examples. Thus, they miss transforming code variations that do not have the exact syntax, data-, or control-flow of the provided input examples, despite being semantically similar. Large Language Models (LLMs), pre-trained on extensive source code datasets, offer a potential solution. Harnessing the capability of LLMs to generate semantically equivalent, yet previously unseen variants of the original CPAT could significantly increase the effectiveness of TBE systems.                In this paper, we first discover best practices for harnessing LLMs to generate code variants that meet three criteria: correctness (semantic equivalence to the original CPAT), usefulness (reflecting what developers typically write), and applicability (aligning with the primary intent of the original CPAT). We then implement these practices in our tool PyCraft, which synergistically combines static code analysis, dynamic analysis, and LLM capabilities. By employing chain-of-thought reasoning, PyCraft generates variations of input examples and comprehensive test cases that identify correct variations with an F-measure of 96.6\\%. Our algorithm uses feedback iteration to expand the original input examples by an average factor of 58x. Using these richly generated examples, we inferred transformation rules and then automated these changes, resulting in an increase of up to 39x, with an average increase of 14x in target codes compared to a previous state-of-the-art tool that relies solely on static analysis. We submitted patches generated by PyCraft to a range of projects, notably esteemed ones like microsoft/DeepSpeed and IBM/inFairness. Their developers accepted and merged 83\\% the 86 CPAT instances submitted through 44 pull requests. This confirms the usefulness of these changes.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "29",
        "numpages": "23",
        "keywords": [
            "code generation",
            "program transformation"
        ],
        "venue": "FSE2024"
    },
    "CodePlan: Repository-Level Coding using LLMs and Planning": {
        "type": "article",
        "key": "10.1145/3643757",
        "author": "Bairi, Ramakrishna and Sonwane, Atharv and Kanade, Aditya and C., Vageesh D. and Iyer, Arun and Parthasarathy, Suresh and Rajamani, Sriram and Ashok, B. and Shet, Shashank",
        "title": "CodePlan: Repository-Level Coding using LLMs and Planning",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643757",
        "doi": "10.1145/3643757",
        "abstract": "Software engineering activities such as package migration, fixing error reports from static analysis or testing, and adding type annotations or other specifications to a codebase, involve pervasively editing the entire repository of code.     We formulate these activities as repository-level coding tasks.         Recent tools like GitHub Copilot, which are powered by Large Language Models (LLMs), have succeeded in offering high-quality solutions to localized coding problems.     Repository-level coding tasks are more involved and cannot be solved directly using LLMs, since code within a repository is inter-dependent and the entire repository may be too large to fit into the prompt.     We frame repository-level coding as a planning problem and present a task-agnostic, neuro-symbolic framework called CodePlan to solve it.     CodePlan synthesizes a multi-step chain-of-edits (plan), where each step results in a call to an LLM on a code location with context derived from the entire repository, previous code changes and task-specific instructions.     CodePlan is based on a novel combination of an incremental dependency analysis, a change may-impact analysis and an adaptive planning algorithm (symbolic components) with the neural LLMs.         We evaluate the effectiveness of CodePlan on two repository-level tasks: package migration (C#) and temporal code edits (Python). Each task is evaluated on multiple code repositories, each of which requires inter-dependent changes to many files (between 2\u201397 files).     Coding tasks of this level of complexity have not been automated using LLMs before. Our results show that CodePlan has better match with the ground truth compared to baselines.     CodePlan is able to get 5/7 repositories to pass the validity checks (i.e., to build without errors and make correct code edits) whereas the baselines (without planning but with the same type of contextual information as CodePlan) cannot get any of the repositories to pass them.     We provide our (non-proprietary) data, evaluation scripts and supplementary material at https://github.com/microsoft/codeplan.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "31",
        "numpages": "24",
        "keywords": [
            "code generation",
            "program synthesis",
            "agent design",
            "planning"
        ],
        "venue": "FSE2024"
    },
    "Only diff Is Not Enough: Generating Commit Messages Leveraging Reasoning and Action of Large Language Model": {
        "type": "article",
        "key": "10.1145/3643760",
        "author": "Li, Jiawei and Farag\\'{o}, David and Petrov, Christian and Ahmed, Iftekhar",
        "title": "Only diff Is Not Enough: Generating Commit Messages Leveraging Reasoning and Action of Large Language Model",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643760",
        "doi": "10.1145/3643760",
        "abstract": "Commit messages play a vital role in software development and maintenance. While previous research has introduced various Commit Message Generation (CMG) approaches, they often suffer from a lack of consideration for the broader software context associated with code changes. This limitation resulted in generated commit messages that contained insufficient information and were poorly readable. To address these shortcomings, we approached CMG as a knowledge-intensive reasoning task. We employed ReAct prompting with a cutting-edge Large Language Model (LLM) to generate high-quality commit messages. Our tool retrieves a wide range of software context information, enabling the LLM to create commit messages that are factually grounded and comprehensive. Additionally, we gathered commit message quality expectations from software practitioners, incorporating them into our approach to further enhance message quality. Human evaluation demonstrates the overall effectiveness of our CMG approach, which we named Omniscient Message Generator (OMG). It achieved an average improvement of 30.2\\% over human-written messages and a 71.6\\% improvement over state-of-the-art CMG methods.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "34",
        "numpages": "22",
        "keywords": [
            "software maintenance and deployment",
            "commit message generation"
        ],
        "venue": "FSE2024"
    },
    "CORE: Resolving Code Quality Issues using LLMs": {
        "type": "article",
        "key": "10.1145/3643762",
        "author": "Wadhwa, Nalin and Pradhan, Jui and Sonwane, Atharv and Sahu, Surya Prakash and Natarajan, Nagarajan and Kanade, Aditya and Parthasarathy, Suresh and Rajamani, Sriram",
        "title": "CORE: Resolving Code Quality Issues using LLMs",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643762",
        "doi": "10.1145/3643762",
        "abstract": "As software projects progress, quality of code assumes paramount importance as it affects reliability, maintainability and security of software. For this reason, static analysis tools are used in developer workflows to flag code quality issues. However, developers need to spend extra efforts to revise their code to improve code quality based on the tool findings. In this work, we investigate the use of (instruction-following) large language models (LLMs) to assist developers in revising code to resolve code quality issues.    We present a tool, CORE (short for COde REvisions), architected using a pair of LLMs organized as a duo comprised of a proposer and a ranker. Providers of static analysis tools recommend ways to mitigate the tool warnings and developers follow them to revise their code. The proposer LLM of CORE takes the same set of recommendations and applies them to generate candidate code revisions. The candidates which pass the static quality checks are retained. However, the LLM may introduce subtle, unintended functionality changes which may go un-detected by the static analysis. The ranker LLM evaluates the changes made by the proposer using a rubric that closely follows the acceptance criteria that a developer would enforce. CORE uses the scores assigned by the ranker LLM to rank the candidate revisions before presenting them to the developer.    We conduct a variety of experiments on two public benchmarks to show the ability of CORE:  (1) to generate code revisions acceptable to both static analysis tools and human reviewers (the latter evaluated with user study on a subset of the Python benchmark),  (2) to reduce human review efforts by detecting and eliminating revisions with unintended changes,  (3) to readily work across multiple languages (Python and Java), static analysis tools (CodeQL and SonarQube) and quality checks (52 and 10 checks, respectively),  and  (4) to achieve fix rate comparable to a rule-based automated program repair tool but with much smaller engineering efforts (on the Java benchmark).  CORE could revise 59.2\\% Python files (across 52 quality checks) so that they pass scrutiny by both a tool and a human reviewer. The ranker LLM reduced false positives by 25.8\\% in these cases. CORE produced revisions that passed the static analysis tool in 76.8\\% Java files (across 10 quality checks) comparable to 78.3\\% of a specialized program repair tool, with significantly much less engineering efforts. We release code, data, and supplementary material publicly at http://aka.ms/COREMSRI.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "36",
        "numpages": "23",
        "keywords": [
            "static analysis",
            "bug detection"
        ],
        "venue": "FSE2024"
    },
    "Towards AI-Assisted Synthesis of Verified Dafny Methods": {
        "type": "article",
        "key": "10.1145/3643763",
        "author": "Misu, Md Rakib Hossain and Lopes, Cristina V. and Ma, Iris and Noble, James",
        "title": "Towards AI-Assisted Synthesis of Verified Dafny Methods",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643763",
        "doi": "10.1145/3643763",
        "abstract": "Large language models show great promise in many domains, including programming. A promise is easy to make but hard to keep, and language models often fail to keep their promises, generating erroneous code. A promising avenue to keep models honest is to incorporate formal verification: generating programs\u2019 specifications as well as code so that the code can be proved correct with respect to the specifications. Unfortunately, existing large language models show a severe lack of proficiency in verified programming.        In this paper, we demonstrate how to improve two pretrained models\u2019 proficiency in the Dafny verification-aware language. Using 178 problems from the MBPP dataset, we prompt two contemporary models (GPT-4 and PaLM-2) to synthesize Dafny methods. We use three different types of prompts: a direct Contextless prompt; a Signature prompt that includes a method signature and test cases, and a Chain of Thought (CoT) prompt that decomposes the problem into steps and includes retrieval augmentation generated example problems and solutions. Our results show that GPT-4 performs better than PaLM-2 on these tasks and that both models perform best with the retrieval augmentation generated CoT prompt. GPT-4 was able to generate verified, human-evaluated, Dafny methods for 58\\% of the problems, however, GPT-4 managed only 19\\% of the problems with the Contextless prompt, and even fewer (10\\%) for the Signature prompt. We are thus able to contribute 153 verified Dafny solutions to MBPP problems, 50 that we wrote manually, and 103 synthesized by GPT-4.        Our results demonstrate that the benefits of formal program verification are now within reach of code generating large language models. Likewise, program verification systems can benefit from large language models, whether to synthesize code wholesale, to generate specifications, or to act as a \"programmer\u2019s verification apprentice\", to construct annotations such as loop invariants which are hard for programmers to write or verification tools to find. Finally, we expect that the approach we have pioneered here \u2014 generating candidate solutions that are subsequently formally checked for correctness \u2014 should transfer to other domains (e.g., legal arguments, transport signaling, structural engineering) where solutions must be correct, where that correctness must be demonstrated, explained and understood by designers and end-users.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "37",
        "numpages": "24",
        "keywords": [
            "code generation",
            "program synthesis",
            "static analysis",
            "program verification"
        ],
        "venue": "FSE2024"
    },
    "COSTELLO: Contrastive Testing for Embedding-Based Large Language Model as a Service Embeddings": {
        "type": "article",
        "key": "10.1145/3643767",
        "author": "Jiang, Weipeng and Zhai, Juan and Ma, Shiqing and Zhang, Xiaoyu and Shen, Chao",
        "title": "COSTELLO: Contrastive Testing for Embedding-Based Large Language Model as a Service Embeddings",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643767",
        "doi": "10.1145/3643767",
        "abstract": "Large language models have gained significant popularity and are often provided as a service (i.e., LLMaaS).  Companies like OpenAI and Google provide online APIs of LLMs to allow downstream users to create innovative applications.  Despite its popularity, LLM safety and quality assurance is a well-recognized concern in the real world, requiring extra efforts for testing these LLMs.  Unfortunately, while end-to-end services like ChatGPT have garnered rising attention in terms of testing, the LLMaaS embeddings have comparatively received less scrutiny.  We state the importance of testing and uncovering problematic individual embeddings without considering downstream applications.  The abstraction and non-interpretability of embedded vectors, combined with the black-box inaccessibility of LLMaaS, make testing a challenging puzzle.  This paper proposes COSTELLO, a black-box approach to reveal potential defects in abstract embedding vectors from LLMaaS by contrastive testing.  Our intuition is that high-quality LLMs can adequately capture the semantic relationships of the input texts and properly represent their relationships in the high-dimensional space.  For the given interface of LLMaaS and seed inputs, COSTELLO can automatically generate test suites and output words with potential problematic embeddings.  The idea is to synthesize contrastive samples with guidance, including positive and negative samples, by mutating seed inputs.  Our synthesis guide will leverage task-specific properties to control the mutation procedure and generate samples with known partial relationships in the high-dimensional space.  Thus, we can compare the expected relationship (oracle) and embedding distance (output of LLMs) to locate potential buggy cases.  We evaluate COSTELLO on 42 open-source (encoder-based) language models and two real-world commercial LLMaaS.  Experimental results show that COSTELLO can effectively detect semantic violations, where more than 62\\% of violations on average result in erroneous behaviors (e.g., unfairness) of downstream applications.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "41",
        "numpages": "23",
        "keywords": [
            "code model training",
            "source code model"
        ],
        "venue": "FSE2024"
    },
    "Code-Aware Prompting: A Study of Coverage-Guided Test Generation in Regression Setting using LLM": {
        "type": "article",
        "key": "10.1145/3643769",
        "author": "Ryan, Gabriel and Jain, Siddhartha and Shang, Mingyue and Wang, Shiqi and Ma, Xiaofei and Ramanathan, Murali Krishna and Ray, Baishakhi",
        "title": "Code-Aware Prompting: A Study of Coverage-Guided Test Generation in Regression Setting using LLM",
        "year": "2024",
        "issue_date": "July 2024",
        "publisher": "Association for Computing Machinery",
        "address": "New York, NY, USA",
        "volume": "1",
        "number": "FSE",
        "url": "https://doi.org/10.1145/3643769",
        "doi": "10.1145/3643769",
        "abstract": "Testing plays a pivotal role in ensuring software quality, yet conventional Search Based Software Testing (SBST) methods often struggle with complex software units, achieving suboptimal test coverage. Recent work using large language models (LLMs) for test generation have focused on improving generation quality through optimizing the test generation context and correcting errors in model outputs, but use fixed prompting strategies that prompt the model to generate tests without additional guidance. As a result LLM-generated testsuites still suffer from low coverage. In this paper, we present SymPrompt, a code-aware prompting strategy for LLMs in test generation. SymPrompt\u2019s approach is based on recent work that demonstrates LLMs can solve more complex logical problems when prompted to reason about the problem in a multi-step fashion. We apply this methodology to test generation by deconstructing the testsuite generation process into a multi-stage sequence, each of which is driven by a specific prompt aligned with the execution paths of the method under test, and exposing relevant type and dependency focal context to the model. Our approach enables pretrained LLMs to generate more complete test cases without any additional training. We implement SymPrompt using the TreeSitter parsing framework and evaluate on a benchmark challenging methods from open source Python projects. SymPrompt enhances correct test generations by a factor of 5 and bolsters relative coverage by 26\\% for CodeGen2. Notably, when applied to GPT-4, SymPrompt improves coverage by over 2x compared to baseline prompting strategies.",
        "journal": "Proc. ACM Softw. Eng.",
        "month": "jul",
        "articleno": "43",
        "numpages": "21",
        "keywords": [
            "program testing",
            "fuzzing"
        ],
        "venue": "FSE2024"
    }
}