{
    "Language-to-Code Translation with a Single Labeled Example": {
        "type": "INPROCEEDINGS",
        "key": "bostrom-etal-2024-language",
        "author": "Bostrom, Kaj and Jhamtani, Harsh and Fang, Hao and Thomson, Sam and Shin, Richard and Xia, Patrick and Van Durme, Benjamin and Eisner, Jason and Andreas, Jacob",
        "booktitle": "EMNLP-main2024",
        "title": "Language-to-Code Translation with a Single Labeled Example",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Tools for translating natural language into code promise natural, open-ended interaction with databases, web APIs, and other software systems. However, this promise is complicated by the diversity and continual development of these systems, each with its own interface and distinct set of features. Building a new language-to-code translator, even starting with a large language model (LM), typically requires annotating a large set of natural language commands with their associated programs. In this paper, we describe ICIP (In-Context Inverse Programming), a method for bootstrapping a language-to-code system using mostly (or entirely) unlabeled programs written using a potentially unfamiliar (but human-readable) library or API. ICIP uses a pre-trained LM to assign candidate natural language descriptions to these programs, then iteratively refines the descriptions to ensure global consistency. Across nine different application domains from the Overnight and Spider benchmarks and text-davinci-003 and CodeLlama-7b-Instruct models, ICIP outperforms a number of prompting baselines. Indeed, in a \u201cnearly unsupervised\u201d setting with only a single annotated program and 100 unlabeled examples, it achieves up to 85% of the performance of a fully supervised system.",
        "keywords": [
            "code generation",
            "program synthesis",
            "benchmark"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.462",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "RealVul: Can We Detect Vulnerabilities in Web Applications with LLM?": {
        "type": "INPROCEEDINGS",
        "key": "cao-etal-2024-realvul",
        "author": "Cao, Di and Liao, Yong and Shang, Xiuwei",
        "booktitle": "EMNLP-main2024",
        "title": "RealVul: Can We Detect Vulnerabilities in Web Applications with LLM?",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "The latest advancements in large language models (LLMs) have sparked interest in their potential for software vulnerability detection. However, there is currently a lack of research specifically focused on vulnerabilities in the PHP language, and challenges in data sampling and processing persist, hindering the model\u2019s ability to effectively capture the characteristics of specific vulnerabilities. In this paper, we present RealVul, the first LLM-based framework designed for PHP vulnerability detection, addressing these issues. By improving code sampling methods and employing normalization techniques, we can isolate potential vulnerability triggers while streamlining the code and eliminating unnecessary semantic information, enabling the model to better understand and learn from the generated vulnerability samples. We also address the issue of insufficient PHP vulnerability samples by improving data synthesis methods. To evaluate RealVul\u2019s performance, we conduct an extensive analysis using five distinct code LLMs on vulnerability data from 180 PHP projects. The results demonstrate a significant improvement in both effectiveness and generalization compared to existing methods, effectively boosting the vulnerability detection capabilities of these models.",
        "keywords": [
            "static analysis",
            "bug detection"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.472",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Code Prompting Elicits Conditional Reasoning Abilities in Text+Code LLMs": {
        "type": "INPROCEEDINGS",
        "key": "puerto-etal-2024-code",
        "author": "Puerto, Haritz and Tutek, Martin and Aditya, Somak and Zhu, Xiaodan and Gurevych, Iryna",
        "booktitle": "EMNLP-main2024",
        "title": "Code Prompting Elicits Conditional Reasoning Abilities in Text+Code LLMs",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Reasoning is a fundamental component of language understanding. Recent prompting techniques, such as chain of thought, have consistently improved LLMs\u2019 performance on various reasoning tasks. Nevertheless, there is still little understanding of what triggers reasoning abilities in LLMs in the inference stage. In this paper, we investigate the effect of the input representation on the reasoning abilities of LLMs. We hypothesize that representing natural language tasks as code can enhance specific reasoning abilities such as entity tracking or logical reasoning. To study this, we propose code prompting, a methodology we operationalize as a chain of prompts that transforms a natural language problem into code and directly prompts the LLM using the generated code without resorting to external code execution. We find that code prompting exhibits a high-performance boost for multiple LLMs (up to 22.52 percentage points on GPT 3.5, 7.75 on Mixtral, and 16.78 on Mistral) across multiple conditional reasoning datasets. We then conduct comprehensive experiments to understand how the code representation triggers reasoning abilities and which capabilities are elicited in the underlying models. Our analysis on GPT 3.5 reveals that the code formatting of the input problem is essential for performance improvement. Furthermore, the code representation improves sample efficiency of in-context learning and facilitates state tracking of entities.",
        "keywords": [
            "prompting strategy",
            "reason with code"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.629",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "CodeAgent: Autonomous Communicative Agents for Code Review": {
        "type": "INPROCEEDINGS",
        "key": "tang-etal-2024-codeagent",
        "author": "Tang, Xunzhu and Kim, Kisub and Song, Yewei and Lothritz, Cedric and Li, Bei and Ezzini, Saad and Tian, Haoye and Klein, Jacques and Bissyand\u00e9, Tegawend\u00e9 F.",
        "booktitle": "EMNLP-main2024",
        "title": "CodeAgent: Autonomous Communicative Agents for Code Review",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Code review, which aims at ensuring the overall quality and reliability of software, is a cornerstone of software development. Unfortunately, while crucial, Code review is a labor-intensive process that the research community is looking to automate. Existing automated methods rely on single input-output generative models and thus generally struggle to emulate the collaborative nature of code review. This work introduces CodeAgent, a novel multi-agent Large Language Model (LLM) system for code review automation. CodeAgent incorporates a supervisory agent, QA-Checker, to ensure that all the agents\u2019 contributions address the initial review question. We evaluated CodeAgent on critical code review tasks: (1) detect inconsistencies between code changes and commit messages, (2) identify vulnerability introductions, (3) validate code style adherence, and (4) suggest code revisions. The results demonstrate CodeAgent\u2019s effectiveness, contributing to a new state-of-the-art in code review automation. Our data and code are publicly available (https://github.com/Daniel4SE/codeagent).",
        "keywords": [
            "software maintenance and deployment",
            "code review",
            "agent design"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.632",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Empowering Multi-step Reasoning across Languages via Program-Aided Language Models": {
        "type": "INPROCEEDINGS",
        "key": "ranaldi-etal-2024-empowering-multi",
        "author": "Ranaldi, Leonardo and Pucci, Giulia and Haddow, Barry and Birch, Alexandra",
        "booktitle": "EMNLP-main2024",
        "title": "Empowering Multi-step Reasoning across Languages via Program-Aided Language Models",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "In-context learning methods are popular inference strategies where Large Language Models (LLMs) are elicited to solve a task using provided demonstrations without parameter updates. Among these approaches are the reasoning methods, best exemplified by Chain-of-Thought (CoT) and Program-Aided Language Models (PAL), which elicit LLMs to generate reasoning paths, thus promoting accuracy and attracting increasing attention. However, despite the success of these methods, the ability to deliver multi-step reasoning remains limited to a single language, making it challenging to generalize to other languages and hindering global development.In this work, we propose Cross-lingual Program-Aided Language Models (CrossPAL), a method for aligning reasoning programs across languages. In particular, our method delivers programs as intermediate reasoning steps in different languages through a double-step cross-lingual prompting mechanism inspired by the Program-Aided approach. In addition, we introduce Self-consistent CrossPAL (SCrossPAL) to ensemble different reasoning paths across languages. Our experimental evaluations show that our method significantly outperforms existing prompting methods, reducing the number of interactions and achieving state-of-the-art performance.",
        "keywords": [
            "prompting strategy",
            "reason with code"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.678",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "DA-Code: Agent Data Science Code Generation Benchmark for Large Language Models": {
        "type": "INPROCEEDINGS",
        "key": "huang-etal-2024-da",
        "author": "Huang, Yiming and Luo, Jianwen and Yu, Yan and Zhang, Yitong and Lei, Fangyu and Wei, Yifan and He, Shizhu and Huang, Lifu and Liu, Xiao and Zhao, Jun and Liu, Kang",
        "booktitle": "EMNLP-main2024",
        "title": "DA-Code: Agent Data Science Code Generation Benchmark for Large Language Models",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "We introduce DA-Code, a code generation benchmark specifically designed to assess LLMs on agent-based data science tasks. This benchmark features three core elements: First, the tasks within DA-Code are inherently challenging, setting them apart from traditional code generation tasks and demanding advanced coding skills in grounding and planning. Second, examples in DA-Code are all based on real and diverse data, covering a wide range of complex data wrangling and analytics tasks. Third, to solve the tasks, the models must utilize complex data science programming languages, including Python and SQL, to perform intricate data processing and derive the answers. We set up the benchmark in a controllable and executable environment that aligns with real-world data analysis scenarios and is scalable. The annotators meticulously designed the evaluation suite to ensure the accuracy and robustness of the evaluation. We developed the DA-Agent baseline. Experiments show that although the baseline performs better than other existing frameworks, using the current best LLMs achieves only 30.5% accuracy, leaving ample room for improvement. We release our benchmark at [link](https://github.com/yiyihum/dabench)",
        "keywords": [
            "code generation",
            "program synthesis",
            "benchmark"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.748",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Leveraging Context-Aware Prompting for Commit Message Generation": {
        "type": "INPROCEEDINGS",
        "key": "jiang-etal-2024-leveraging-context",
        "author": "Jiang, Zhihua and Chen, Jianwei and Rao, Dongning and Ye, Guanghui",
        "booktitle": "EMNLP-main2024",
        "title": "Leveraging Context-Aware Prompting for Commit Message Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Writing comprehensive commit messages is tedious yet important, because these messages describe changes of code, such as fixing bugs or adding new features. However, most existing methods focus on either only the changed lines or nearest context lines, without considering the effectiveness of selecting useful contexts. On the other hand, it is possible that introducing excessive contexts can lead to noise. To this end, we propose a code model COMMIT (Context-aware prOMpting based comMIt-message generaTion) in conjunction with a code dataset CODEC (COntext and metaData Enhanced Code dataset). Leveraging program slicing, CODEC consolidates code changes along with related contexts via property graph analysis. Further, utilizing CodeT5+ as the backbone model, we train COMMIT via context-aware prompt on CODEC. Experiments show that COMMIT can surpass all compared models including pre-trained language models for code (code-PLMs) such as CommitBART and large language models for code (code-LLMs) such as Code-LlaMa. Besides, we investigate several research questions (RQs), further verifying the effectiveness of our approach. We release the data and code at: https://github.com/Jnunlplab/COMMIT.git.",
        "keywords": [
            "software maintenance and deployment",
            "commit message generation"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.749",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "How Do Your Code LLMs perform? Empowering Code Instruction Tuning with Really Good Data": {
        "type": "INPROCEEDINGS",
        "key": "wang-etal-2024-code",
        "author": "Wang, Yejie and He, Keqing and Fu, Dayuan and GongQue, Zhuoma and Xu, Heyang and Chen, Yanxu and Wang, Zhexu and Fu, Yujia and Dong, Guanting and Diao, Muxi and Wang, Jingang and Zhang, Mengdi and Cai, Xunliang and Xu, Weiran",
        "booktitle": "EMNLP-main2024",
        "title": "How Do Your Code LLMs perform? Empowering Code Instruction Tuning with Really Good Data",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recently, there has been a growing interest in studying how to construct better code instruction tuning data. However, we observe Code models trained with these datasets exhibit high performance on HumanEval but perform worse on other benchmarks such as LiveCodeBench. Upon further investigation, we find that many datasets suffer from severe data leakage. After cleaning up most of the leaked data, some well-known high-quality datasets perform poorly. This discovery reveals a new challenge: identifying which dataset genuinely qualify as high-quality code instruction data. To address this, we propose an efficient code data pruning strategy for selecting good samples. Our approach is based on three dimensions: instruction complexity, response quality, and instruction diversity. Based on our selected data, we present XCoder, a family of models finetuned from LLaMA3. Our experiments show Xcoder achieves new state-of-the-art performance using fewer training data, which verify the effectiveness of our data strategy. Moreover, we perform a comprehensive analysis on the data composition and find existing code datasets have different characteristics according to their construction methods, which provide new insights for future code LLMs.",
        "keywords": [
            "code model training",
            "source code model"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.777",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "ECCO: Can We Improve Model-Generated Code Efficiency Without Sacrificing Functional Correctness?": {
        "type": "INPROCEEDINGS",
        "key": "waghjale-etal-2024-ecco",
        "author": "Waghjale, Siddhant and Veerendranath, Vishruth and Wang, Zhiruo and Fried, Daniel",
        "booktitle": "EMNLP-main2024",
        "title": "ECCO: Can We Improve Model-Generated Code Efficiency Without Sacrificing Functional Correctness?",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Although large language models (LLMs) have been largely successful in generating functionally correct programs, conditioning models to produce efficient solutions while ensuring correctness remains a challenge. Further, unreliability in benchmarking code efficiency is a hurdle across varying hardware specifications for popular interpreted languages such as Python. In this paper, we present ECCO, a reproducible benchmark for evaluating program efficiency via two paradigms: natural language (NL) based code generation and history-based code editing. On ECCO, we adapt and thoroughly investigate the three most promising existing LLM-based approaches: in-context learning, iterative refinement with execution or NL feedback, and fine-tuning conditioned on execution and editing history. While most methods degrade functional correctness and moderately increase program efficiency, we find that adding execution information often helps maintain functional correctness, and NL feedback enhances more on efficiency. We release our benchmark to support future work on LLM-based generation of efficient code.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.859",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Re-Reading Improves Reasoning in Large Language Models": {
        "type": "INPROCEEDINGS",
        "key": "xu-etal-2024-reading",
        "author": "Xu, Xiaohan and Tao, Chongyang and Shen, Tao and Xu, Can and Xu, Hongbo and Long, Guodong and Lou, Jian-Guang and Ma, Shuai",
        "booktitle": "EMNLP-main2024",
        "title": "Re-Reading Improves Reasoning in Large Language Models",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "To enhance the reasoning capabilities of off-the-shelf Large Language Models (LLMs), we introduce a simple, yet general and effective prompting method, RE2, i.e., Re-Reading the question as input. Unlike most thought-eliciting prompting methods, such as Chain-of-Thought (CoT), which aim to elicit the reasoning process in the output, RE2 shifts the focus to the input by processing questions twice, thereby enhancing the understanding process. Consequently, RE2 demonstrates strong generality and compatibility with most thought-eliciting prompting methods, including CoT. Crucially, RE2 facilitates a \u201cbidirectional\u201d encoding in unidirectional decoder-only LLMs because the first pass could provide global information for the second pass. We begin with a preliminary empirical study as the foundation of RE2, illustrating its potential to enable \u201cbidirectional\u201d attention mechanisms. We then evaluate RE2 on extensive reasoning benchmarks across 14 datasets, spanning 112 experiments, to validate its effectiveness and generality. Our findings indicate that, with the exception of a few scenarios on vanilla ChatGPT, RE2 consistently enhances the reasoning performance of LLMs through a simple re-reading strategy. Further analyses reveal RE2\u2019s adaptability, showing how it can be effectively integrated with different LLMs, thought-eliciting prompting, and ensemble strategies.",
        "keywords": [
            "prompting strategy"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.871",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Which Programming Language and What Features at Pre-training Stage Affect Downstream Logical Inference Performance?": {
        "type": "INPROCEEDINGS",
        "key": "uchiyama-etal-2024-programming",
        "author": "Uchiyama, Fumiya and Kojima, Takeshi and Gambardella, Andrew and Cao, Qi and Iwasawa, Yusuke and Matsuo, Yutaka",
        "booktitle": "EMNLP-main2024",
        "title": "Which Programming Language and What Features at Pre-training Stage Affect Downstream Logical Inference Performance?",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recent large language models (LLMs) have demonstrated remarkable generalization abilities in mathematics and logical reasoning tasks.Prior research indicates that LLMs pre-trained with programming language data exhibit high mathematical and reasoning abilities; however, this causal relationship has not been rigorously tested. Our research aims to verify which programming languages and features during pre-training affect logical inference performance. Specifically, we pre-trained decoder-based language models from scratch using datasets from ten programming languages (e.g., Python, C, Java) and three natural language datasets (Wikipedia, Fineweb, C4) under identical conditions. Thereafter, we evaluated the trained models in a few-shot in-context learning setting on logical reasoning tasks: FLD and bAbi, which do not require commonsense or world knowledge. The results demonstrate that nearly all models trained with programming languages consistently outperform those trained with natural languages, indicating that programming languages contain factors that elicit logic inference performance. In addition, we found that models trained with programming languages exhibit a better ability to follow instructions compared to those trained with natural languages. Further analysis reveals that the depth of Abstract Syntax Trees representing parsed results of programs also affects logical reasoning performance. These findings will offer insights into the essential elements of pre-training for acquiring the foundational abilities of LLMs.",
        "keywords": [
            "code model training",
            "source code model",
            "empirical study"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1008",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "DocCGen: Document-based Controlled Code Generation": {
        "type": "INPROCEEDINGS",
        "key": "pimparkhede-etal-2024-doccgen",
        "author": "Pimparkhede, Sameer and Kammakomati, Mehant and Tamilselvam, Srikanth G. and Kumar, Prince and Kumar, Ashok Pon and Bhattacharyya, Pushpak",
        "booktitle": "EMNLP-main2024",
        "title": "DocCGen: Document-based Controlled Code Generation",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Recent developments show that Large Language Models (LLMs) produce state-of-the-art performance on natural language (NL) to code generation for resource-rich general-purpose languages like C++, Java, and Python. However, their practical usage for structured domain-specific languages (DSLs) such as YAML, JSON is limited due to domain-specific schema, grammar, and customizations generally unseen by LLMs during pre-training. Efforts have been made to mitigate this challenge via in-context learning through relevant examples or by fine-tuning. However, it suffers from problems, such as limited DSL samples and prompt sensitivity but enterprises maintain good documentation of the DSLs. Therefore, we propose DocCGen, a framework that can leverage such rich knowledge by breaking the NL-to-Code generation task for structured code languages into a two-step process. First, it detects the correct libraries using the library documentation that best matches the NL query. Then, it utilizes schema rules extracted from the documentation of these libraries to constrain the decoding. We evaluate our framework for two complex structured languages, Ansible YAML and Bash command, consisting of two settings: Out-of-domain (OOD) and In domain (ID). Our extensive experiments show that DocCGen consistently improves different sized language models across all six evaluation metrics, reducing syntactic and semantic errors in structured code.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1040",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "CoCoST: Automatic Complex Code Generation with Online Searching and Correctness Testing": {
        "type": "INPROCEEDINGS",
        "key": "he-etal-2024-cocost",
        "author": "He, Xinyi and Zou, Jiaru and Lin, Yun and Zhou, Mengyu and Han, Shi and Yuan, Zejian and Zhang, Dongmei",
        "booktitle": "EMNLP-main2024",
        "title": "CoCoST: Automatic Complex Code Generation with Online Searching and Correctness Testing",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models have revolutionized code generation ability by converting natural language descriptions into executable code. However, generating complex code within real-world scenarios remains challenging due to intricate structures, subtle bugs, understanding of advanced data types, and lack of supplementary contents. To address these challenges, we introduce the CoCoST framework, which enhances complex code generation by online searching for more information with planned queries and correctness testing for code refinement. Moreover, CoCoST serializes the complex inputs and outputs to improve comprehension and generates test cases to ensure the adaptability for real-world applications. CoCoST is validated through rigorous experiments on the DS-1000 and ClassEval datasets. Experimental results show that CoCoST substantially improves the quality of complex code generation, highlighting its potential to enhance the practicality of LLMs in generating complex code.",
        "keywords": [
            "code generation",
            "program synthesis",
            "benchmark"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1082",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "CodeJudge: Evaluating Code Generation with Large Language Models": {
        "type": "INPROCEEDINGS",
        "key": "tong-zhang-2024-codejudge",
        "author": "Tong, Weixi and Zhang, Tianyi",
        "booktitle": "EMNLP-main2024",
        "title": "CodeJudge: Evaluating Code Generation with Large Language Models",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Large Language Models (LLMs) have shown promising performance in code generation. However, how to reliably evaluate code generated by LLMs remains an unresolved problem. This paper presents CodeJudge, a code evaluation framework that leverages LLMs to evaluate the semantic correctness of generated code without the need for test cases. We investigate different ways to guide the LLM in performing \u201cslow thinking\u201d to arrive at an in-depth and reliable evaluation. We experimented with four LLMs as evaluators on four code generation datasets and five programming languages. The results show that CodeJudge significantly outperformed existing methods in most settings. Furthermore, compared with a SOTA GPT-3.5-based code evaluation method, CodeJudge achieved better results even when using a much smaller model, Llama-3-8B-Instruct. Our code and datasets are available on GitHub https://github.com/VichyTong/CodeJudge.",
        "keywords": [
            "code generation",
            "program synthesis"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1118",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "EHRAgent: Code Empowers Large Language Models for Few-shot Complex Tabular Reasoning on Electronic Health Records": {
        "type": "INPROCEEDINGS",
        "key": "shi-etal-2024-ehragent",
        "author": "Shi, Wenqi and Xu, Ran and Zhuang, Yuchen and Yu, Yue and Zhang, Jieyu and Wu, Hang and Zhu, Yuanda and Ho, Joyce C. and Yang, Carl and Wang, May Dongmei",
        "booktitle": "EMNLP-main2024",
        "title": "EHRAgent: Code Empowers Large Language Models for Few-shot Complex Tabular Reasoning on Electronic Health Records",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Clinicians often rely on data engineers to retrieve complex patient information from electronic health record (EHR) systems, a process that is both inefficient and time-consuming. We propose EHRAgent, a large language model (LLM) agent empowered with accumulative domain knowledge and robust coding capability. EHRAgent enables autonomous code generation and execution to facilitate clinicians in directly interacting with EHRs using natural language. Specifically, we formulate a multi-tabular reasoning task based on EHRs as a tool-use planning process, efficiently decomposing a complex task into a sequence of manageable actions with external toolsets. We first inject relevant medical information to enable EHRAgent to effectively reason about the given query, identifying and extracting the required records from the appropriate tables. By integrating interactive coding and execution feedback, EHRAgent then effectively learns from error messages and iteratively improves its originally generated code. Experiments on three real-world EHR datasets show that EHRAgent outperforms the strongest baseline by up to 29.6% in success rate, verifying its strong capacity to tackle complex clinical tasks with minimal demonstrations.",
        "keywords": [
            "prompting strategy",
            "reason with code"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1245",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Language Models as Compilers: Simulating Pseudocode Execution Improves Algorithmic Reasoning in Language Models": {
        "type": "INPROCEEDINGS",
        "key": "chae-etal-2024-language",
        "author": "Chae, Hyungjoo and Kim, Yeonghyeon and Kim, Seungone and Ong, Kai Tzu-iunn and Kwak, Beong-woo and Kim, Moohyeon and Kim, Sunghwan and Kwon, Taeyoon and Chung, Jiwan and Yu, Youngjae and Yeo, Jinyoung",
        "booktitle": "EMNLP-main2024",
        "title": "Language Models as Compilers: Simulating Pseudocode Execution Improves Algorithmic Reasoning in Language Models",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "Algorithmic reasoning tasks that involve complex logical patterns, such as completing Dyck language, pose challenges for large language models (LLMs), despite their recent success. Prior work has used LLMs to generate programming language and applied external compilers for such tasks. Yet, when on the fly, it is hard to generate an executable code with the correct logic for the solution. Even so, code for one instance cannot be reused for others, although they might require the same logic to solve. We present Think-and-Execute, a novel framework that improves LLMs\u2019 algorithmic reasoning: (1) In Think, we discover task-level logic shared across all instances, and express such logic with pseudocode; (2) In Execute, we tailor the task-level pseudocode to each instance and simulate the execution of it. Think-and-Execute outperforms several strong baselines (including CoT and PoT) in diverse algorithmic reasoning tasks. We manifest the advantage of using task-level pseudocode over generating instance-specific solutions one by one. Also, we show that pseudocode can better improve LMs\u2019 reasoning than natural language (NL) guidance, even though they are trained with NL instructions.",
        "keywords": [
            "static analysis",
            "foundamental analysis"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1253",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    },
    "Coffee-Gym: An Environment for Evaluating and Improving Natural Language Feedback on Erroneous Code": {
        "type": "INPROCEEDINGS",
        "key": "chae-etal-2024-coffee",
        "author": "Chae, Hyungjoo and Kwon, Taeyoon and Moon, Seungjun and Song, Yongho and Kang, Dongjin and Ong, Kai Tzu-iunn and Kwak, Beong-woo and Bae, Seonghyeon and Hwang, Seung-won and Yeo, Jinyoung",
        "booktitle": "EMNLP-main2024",
        "title": "Coffee-Gym: An Environment for Evaluating and Improving Natural Language Feedback on Erroneous Code",
        "year": "2024",
        "volume": "",
        "number": "",
        "pages": "",
        "abstract": "This paper presents Coffee-Gym, a comprehensive RL environment for training models that provide feedback on code editing. Coffee-Gym includes two major components: (1) Coffee, a dataset containing humans\u2019 code edit traces for coding questions and human-written feedback for editing erroneous code; (2) CoffeeEval, a reward function that faithfully reflects the helpfulness of feedback by assessing the performance of the revised code in unit tests. With them, Coffee-Gym addresses the unavailability of high-quality datasets for training feedback models with RL, and provides more accurate rewards than the SOTA reward model (i.e., GPT-4). By applying Coffee-Gym, we elicit feedback models that outperform baselines in enhancing open-source code LLMs\u2019 code editing, making them comparable with closed-source LLMs. We make the dataset and the model checkpoint publicly available in https://huggingface.co/spaces/Coffee-Gym/Project-Coffee-Gym.",
        "keywords": [
            "code generation",
            "program repair",
            "benchmark"
        ],
        "url": "https://aclanthology.org/2024.emnlp-main.1254",
        "doi": "",
        "ISSN": "",
        "month": "November",
        "venue": "EMNLP-main2024"
    }
}